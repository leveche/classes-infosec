#+title: Enterprise Linux Security Administration
*** Security Concepts
- Minimization
  - every installed component is a security risk, no such thing as
    innocuous service
    - every running component doubly so
      - services are no longer configured to start on boot by install
        scripts
  - discovery
    - packaged software
      - =rpm -qa=: all packages installed on system
      - =rpm -qi pkg=: info about package =pkg=
      - =rpm -ql pkg=: all files provided in package
      - =rpm -qf file=: which package provided the file
      - =rpm -qlp pkg.rpm=
      - lab (~5 mins)
        - objectives
          - use =rpm= do discover what packages are installed
          - trace dependency chain
        - tasks
          - list all packages installed
          - how many are there?
          - which package does =/usr/bin/openssl= belong to?
          - what packages require that package as dependencies?
          - now remove the packages in question
          - is this it?
            - =rpm -q --whatrequires $(rpm -q --provides openssl) | sort -u=
          - are we done now?
            - what do the packages we removed provide, and what
              depends on *that*?
    - unpackaged software
      - =find /where -user userid -exec rm {} \;=
      - =-ok= is like =-exec= but asks first
    - running processes
      - =chkconfig=
      - =netstat -taupe=
      - =ss -taupe=
      - =ps auxw=
      - =lsof -i=
      - lab (~5 minutes)
        - objectives
          - identify running processes
          - disable and uninstall unneeded software
        - tasks
          - which processes are configured to start at boot?
          - disable =avahi=, =bluetooth=, =xinetd= from starting on boot
          - what is listening on network?
            - =ss -taupe | grep LISTEN=
            - =lsof -i=
          - remove =xinetd= from the system
            - =rpm -e=
- Hardening
  - Already need a picture of who is going to access the service and
    what level of access they need
  - Do not trust default config!
  - Simplify!
  - packet filtering
    - pre-firewalld
      - config persists in =/etc/sysconfig/ip{,6}tables=
    - firewalld
  - service wrapping
    - =xinetd=
  - Authentication
    - PAM
      - shortcomings of PAM
  - minimizing service capabilities
    - least-privilege principle
    - =setuid=
    - POSIX 1003.1e capabilities
      - =capability.h=
      - =libcap=
        - =sucap=, =execcap=, =getpcaps=, =setpcaps=
      - lab 10 minutes
        - objectives
          - examine use of =capset()= and =setuid()= system calls
        - tasks
          - make sure =ntpd= is installed and running
          - what are the real and effective credentials of the =ntpd= process?
            - =ps -C ntpd -o comm,pid,ruser,euser,rgroup,egroup=
            - how does user =ntp= bind to port =tcp 123=, and how can
              it change system clock?
          - restart =ntpd= with tracing:
            - =strace -f ntpd -u ntp:ntp -g 2> ntp-calls &=
            - =grep -n bind ntp-calls | grep AF_INET=
            - =grep -n -B 5 capset ntp-calls=
              - which capabilities does it retain?
              - how does it change its effective user & group?
            - =grep -e [UG]id -e ^Cap /proc/$(pgrep ntpd)/status=
              - look for =Uid, Gid, Cap{Inh,Prm,Eff}=
    - =chroot=
      - lab 10 minutes
        - objectives
          - examine security implications of =chroot()=
        - tasks
          - install =busibox=
          - copy busibox and bash to =/tmp/jail=
          - =ldd *=, copy libraries to =/tmp/jail/lib=
          - =chroot /tmp/jail/bash=
          - =ls= does not exist!
          - use commands provided by =busybox=
          - from outside the jail, run =ls -la /proc/$(pgrep -xf /bash)/{cdw,root}=
      - SELinux is better!
        - no need to maintain multiple copies of software
*** Scanning, Probing, and Mapping Vulnerabilities
- The Security Environment
  - Reconnaissance
    - public info
      - information never dies
      - profiling from public forums
      - WHOIS database
        - admin and technical contacts
        - netblock maintainer of the IP address
      - DNS
        - reverse lookup on target's IP address
          - why stop at one address? try nearby ones as well!
        - zone transfers
          - bulk transfer of all DNS entries in a zone
            - =host -l example.com=
    - discovery
      - =ping=
      - flood ping =fping=
      - =nmap=
        - ping sweep =nmap -sP 192.168.0.0/16=
          - if ICMP echo is filtered, try ICMP timestamp, or TCP
            connection to well-known ports
            - www.iana.org/assignments/port-numbers
            - /etc/services
        - IP stack and service fingerprinting
          - =nmap -sV -O target.example.org=
        - Lab (30 mins)
          - objectives
            - use =nmap= to discover and fingerprint services
          - tasks
            - install =wireshark=
            - ping scan of local network
              - =nmap -v -sP 192.168.0.0/24=
            - run ping scan again while running pcap:
              - =tshark -n=
              - what is the output?
            - run TCP connect() scan:
              - =nmap -sT target=
                - what flags are set in the scan packet?
                  - in the response for listening ports?
                  - closed ports?
              - decoy hosts
                - =nmap -sS -D decoy1,decoy2 target=
                - what will decoys see?
            - try =-f= option to fragment packets, see tshark output
            - try null and xmas scans
      - SNMP
        - UDP port 161 and 162 (snmptrapd)
        - =snmpnetstat -v2c -c public -Cr 192.168.32.2=
          - =-r= requests routing table
          - =-a= shows all socket info
        - =snmpwalk -c public -v2c 192.168.32.2=
      - RPC
        - portmapper listens on TCP port 111
        - applications select a free port to listen on, and register
          themselves with portmapper
          - =rpcinfo -p target.example.com=
          - =nmap= can still identify RPC applications even if it
            can't reach portmapper
      - enumerating NFS shares
        - =showmount -e target=
          - =-e= lists exports, =-a= shows active mounts
    - Insecurity Scanners
      - Nessus/ openVAS
        - NASL, Nessus Attack Vulnerability Language
          - update rules with =openvas-nvt-sync=
          - agent/server model
          - lab?: install openvas, tshark while it's running
  - Exploit Services
    - www.securityfocus.com
  - install backdoor
    - escalate privileges
    - rootkit
  - cover tracks
    - logsweeps
*** Password Security and PAM
- local vs network passwords: =/etc/nsswitch=
- =/etc/passwd= -> =/etc/shadow=: =pwconv=
- trapdoor function: hashing
  - =crypt()=: DES encryption of password with itself as key (?)
    - weak!
  - =md5=, =bcrypt=, =sha256=, =sha512=
- password ageing
  - =/etc/shadow=: =chage=
- auditing passwords
  - John the ripper from openwall project
    - checkpointing: =session:FILE=, =-restore=
    - wordlists
    - Lab: use JTR to audit passwords
      - install JTR
      - =john -test=
      - create new user and set a password
      - unshadow the password file: =unshadow /etc/{passwd,shadow} > /tmp/passwords=
      - =john /tmp/passwords=
      - download wordlist and use it to seed JTR
        - =john -wordlist:morewords /tmp/passwords=
      - recompile a new master wordlist on the system
  - PAM
    - =/etc/pam.d=
    - is PAM support linked into the binary?
       =ldd /usr/sbin/sshd | grep libpam=
    - PAM Services (module types)
      - auth
        - authentication: verify identity, grant group memberships
      - account
        - authorization: is the user allowed to use this service at this moment?
      - password
        - used for password changes
      - session
        - executes code at start/end of a session. E.g. =ulimit=
    - a given module can provide more than one type:
      e.g. =pam_unix.so= can be invoked as any of the four types.
    - program checks its own PAM config file in =/etc/pam.d=, falls back to =other=
    - =include= statement to reduce code duplication
    - top-down processing, flow control statements in config
      - =required=
        - fails the stack, but processing continues
      - =requisite=
        - fails the stack, processing terminates
      - =sufficient=
        - passes the stack unless previous module failed it. processing terminates
      - =optional=
        - no decision on stack success
    - module menagery
      - ls =/lib/security=
      - =pam_unix=
        - refers to Name Service Switch to determine auth backend
        - can e.g. obtain kerberos ticket before session opened
        - password ageing, session logging
        - =use_first_pass= vs =try_first_pass=
      - =pam_pwcheck=
        - password strength enforcement
      - =pam_xauth=
        - transfers =X= cookies e.g. after =su=
        - =.Xauthority=
          - =~/.xauth/{import,export}= controls from/to which users
            this user can share cookies
      - =pam_tally2=
        - keep list of failed logins, can lock out
      - =pam_wheel=
        - policy on who can =su= to =root=
      - =pam_nologin=
        - if =/etc/nologin= exists, no non-root user can login
      - =pam_deny=
        - denies everything, secure default to terminate every stack
      - =pam_warn=
        - forces logging
      - =pam_securetty=
        - forces =root= to login through a 'secure' TTY, as listed in =/etc/securetty=
      - =pam_time=
        - enforces policy of which services will allow which users during which times through which ttys
      - =pam_access=
        - restricts access based on the location:
          =/etc/security/access.conf=: =permissions: users: origins=,
          where =origins= lists TTYs or hostnames
        - Lab: restrict user access from specified IPs
          - =/etc/pam.d/sshd=
            - =account required pam_access.so=
          - =/etc/security/access.conf=
            - =-:testuser1:ALL EXCEPT station1.example.com=
      - =pam_listfile=
        - arbitrary text files as a source of access control. Specify
          sense (allow/deny), item: user, tty, rhost, ruser, group,
          shell
        - Lab: restrict ssh access to a list of authorized users with
          =pam_listfile=
          - =/etc/pam.d/sshd=:
            - =auth required pam_listfile.so sense=allow item=user file=/etc/ssh_permit=
      - =pam_lastlog=
        - display time and location of last login. Taken from
          =/var/log/lastlog=
      - =pam_console=
        - set privileges on local tty differently from remote
          access. =/etc/security/console.perms=.
*** Securing NTP
- =hwclock=
- =date=
- NTP terms
  - resolution
    - smallest interval measurable by clock
  - precision
  - jitter
  - accuracy
  - frequency error
  - reliability
  - wander
- synchronization services
  - Digital Time Sync Service (DTSS)
  - NTP: RFC 958(v0), 1059(v1), 1119(v2), 1305(v3)
- NTP v4
  - client-server & broadcast
    - multicast on 224.0.1.1, ff05::101
  - server hierarchy
    - stratum 0,1,2,..15
- =ntpdate=
  - slew vs jump update
- =ntpd=
  - multicastclient/broadcastclient
  - =broadcast 244.0.1.1= for multicast
  - driftfile
  - panic threshold
- =ntp.conf=
  - =restrict ntp1.example.com nomodify=
    - trust the time from =ntp1= but disallow it from modifying
      configuration
  - =restrict 172.16.1.0 mask 255.255.255.0 nomodify noquery=
- NTP integrity
  - symmetric encryption support in NTPv3 and v4
    - =/etc/ntp.conf=:
      - =keys   /etc/ntp/keys=
  - NTPv4 also supports 'autokey' (public key) encryption
    - =/etc/ntp.conf=:
      - =crypto /path/to/cert /path/to/rsa_key=
- =ntpq=
- =ntpc=
- =ntptrace=
- =ntpstat=
*** Kerberos
**** Concepts and Components
- 'crustacean' model of network security: fortify the perimeter and
  trust the internal network
- RFC 1510
- central trusted server, KDC, that authenticates and issues tickets
- authentication only, authorization is up to the service
- principals:
  - name, e.g. =user/admin@EXAMPLE.ORG=, has 3 components:
    - primary: =user=. For services, indicates service type,
      e.g. =host/= or =ldap/=
    - instance: mandatory for service principals. For users, usually
      used to modify capabilities given to the principal
    - realm: =EXAMPLE.ORG=
- session replay protection
  - each ticket carries a sequence number
  - sequence numbers do no roll over in the validity window, usually 5
    mins
- Kerberos Components
  - Authentication Server (AS)
  - Ticket-Granting Servier (TGS)
  - kerberized services using KDC
- GSSAPI
- SASL
**** Authentication Process
#+BEGIN_SRC plantuml :file tmp/krb5_auth_process.png :cache yes
@startuml
"Client Workstation" --> "Authentication Server": obtain tgt
"Authentication Server" --> "Client Workstation": obtain sgt for service 1
"Client Workstation" --> "Kerberized Service 1": use sgt for service 1
"Client Workstation" --> "Authentication Server": obtain sgt for service 2
"Client Workstation" --> "Kerberized Service 2": use sgt for service 2
@enduml
#+END_SRC
**** ticket attributes
- kerberos version + realm, unencrypted
- principal of the service, unencrypted
- principal of the user, unencrypted
- IP address of client host
- issued timestamp
- expiry timestamp
- session key to encrypt communication between client and service
**** Authenticators
encrypted with tgt, opague for the client
contains
- Client's principal
- hash of the ticket
- timestamp issued
- sequence number to prevent replay attacks
**** logging in
- obtain TGT. Optionally, AS can be set to require a pre-authenticator with the tgt request
- the pre-authenticator is salt + timestamp encrypted with the principal's password
- prevents brute-force attacks on krb AS service
**** TGT request
- pre-authenticator
- message type = 10
- timestamps
- flags
- user principal
**** TGT response
- message type = 11
- user principal
- encrypted with the user principal's key
  - timestamps
  - flags
  - client IP(s)
  - server TGS principal
  - session key
- encrypted with TGS key
  - TGS principal
  - timestamps
  - client IP(s)
  - user principal
  - session key
**** SGT request
- request body
  - message type = 12
  - timestamps
  - flags
  - client IP(s)
  - supported enctypes
- TGT ticket, encrypted with TGS key
  - copied verbatim from TGT
- authenticator, encrypted with session key
  - user principal
  - hash of request body
  - timestamps
  - sequence number
**** SGT response
- message type = 13
- user principal
- encrypted with user principal's key
  - timestamps
  - flags
  - client IPs
  - service principal
  - sub-session key
- SGT, encrypted with service's secret key
  - service principal
  - timesamps
  - flags
  - client IPs
  - user principal
  - sub-session key
**** Service Access Request
- request body
  - message type = 14
  - mutual auth request
- service ticket: copied from SGT
- authenticator, encrypted with session sub-key
  - user principal
  - hash or request body
  - timestamps
  - sequence number
**** Mutual Authentication Response
- message type = 15
- encrypted with session subkey
  - timestamps
  - sequence number
**** Kerberos Components
- KDC
  - Authentication Service (AS)
  - Ticket-Granting Service (TGS)
- kerbrized services
  - telnet
  - ftp
  - rsh/rlogin/rcp
  - ssh
  - ksu
  - thunderbird
  - firefox
  - ssh
  - printing
  - imap/pop/smtp
  - web server
  - nfs
  - afs
**** kerberos setup
***** KDC
- krb5kdc
- kpropd
- kadmind
***** utilities
- master KDC
  - kdb5_util
  - kprop
- admin clients
  - kadmin
  - ktutil
- principal
  - kinit
  - pam_krb5
  - klist
  - kdestroy
  - kpasswd
**** kerberos daemon + utility relationships
kprop on kdc master -> kpropd on kdc slaves
kamdin on client -> kadmind on master kdc
kinit on client  -> krb5kdc on kdc (master or slave)
**** administering and using kerberos
***** configuring master KDC

#+BEGIN_EXAMPLE /etc/kdc.conf
[kdcdefaults]
kdc_ports = 88
kdc_tcp_ports = 88

[realms]
EXAMPLE.COM = {
  acl_file     = /var/kerberos/krb5kdc/kadm5.acl
  dict_file    = /usr/share/dict/words
  admin_keytab = /var/kerberos/krb5kdc/kadm5.keytab
  supported_enctypes = aes256-cts:normal
}
#+END_EXAMPLE
***** KDC logging

Three types of data to be logged:
- default
- kdc: KDC logs
- admin_server

five possible destinations:
- FILE:filename: log to file
- STDERR: log to standard error
- CONSOLE: log to system console
- DEVICE=devicename: log to specified device
- SYSLOG:[severity:facility]: log to syslog

#+BEGIN_EXAMPLE /etc/krb5.conf
[logging]
kdc=CONSOLE
kdc=SYSLOG:NOTICE:DAEMON
admin_server=FILE:/var/log/kadmin.log
#+END_EXAMPLE

***** KDC realm defaults

- libdefaults: defaults for all krb libraries
- appdefaults: defaults for specific client apps
- realms: realms used by client
- domain_realm: map DNS domain names -> realm names
- logging: kerb client logging
- capaths: x-realm authentications

#+BEGIN_EXAMPLE
[libdefaults]
default_realm = EXAMPLE.COM
dns_lookup_realm = false
dns_lookup_kdc   = false
ticket_lifetime  = 24h
renew_lifetime   = 7d
forwardable      = yes
#+END_EXAMPLE

#+BEGIN_EXAMPLE
[realms]
EXAMPLE.COM = {
  kdc = server1.example.com
  kdc = server2.example.com
  admin_server = server1.example.com
}
#+END_EXAMPLE

***** DNS autoconfig
#+BEGIN_EXAMPLE
$ORIGIN example.com

_kerberos              TXT   "EXAMPLE.COM"
_kerberos._udp         SRV   0 0 88 server1.example.com
                       SRV   0 0 88 server2.example.com
_kerberos-master._udp  SRV   0 0 99 server1.example.com
_kerberos-adm._tcp     SRV   0 0 749 server1.example.com
_kpasswd._udp          SRV   0 0 464 server1.example.com
#+END_EXAMPLE
***** keytabs
- keytab for =kadmind= on RHEL is in =/var/kerberos/krb5kdc/kadm5/keytab=
- fetch keys and save in keytabs with MIT kerberos: =kadmin=
  - =getprinc=, =list_principals=, etc
- read and modify local keytabs: =ktutil=
***** ticket types
- initial: issued directly to principal. non-initial are granted on
  the basis of another ticket
- forwardable
- proxiable: used by services to authenticate on behalf of principals
- renewable
- postdatable: validity of tickets starts in the future. used e.g. by
  cronjobs
- invalid: used e.g. by postdated tickets before they are valid
***** managing principals
attributes
| allow_forwardable |
| allow_postdated   |
| allow_proxiable   |
| requires_preauth  |
| requires_hwauth   |
| allow_svr         |
| allow_tix         |
| needschange       |
***** principal policies
- maxlife
- minlife
- minlife
- minlength
- minclasses
- history
***** securing workstation login
use =*K*= in =/etc/shadow= to indicate the principal should
authenticate via kerberos. e.g. =useradd -p "*K*" user=

on RHEL6, the pam config bypasses obtaining kerberos ticket if unix
password is set:
#+BEGIN_EXAMPLE pam_config
auth sufficient pam_unix.so try_first_pass
auth sufficient pam_krb5.so use_first_pass

- =ksu= command:
  - =~/.k5login= lists principals allowed to log in as that user
  - "kerberized sudo": =~/.k5users= specifies which kerberos principal is allowed to execute specific commands
#+END_EXAMPLE
***** forwarding kerberos tickets
- non-forwardable TGT =kinit -F=
- =telnet -x= to have telnet try to use krb5. it's the default with
  newer versions onf telnet
- =telnet -xF= will forward local credentials to the remote system
***** securing ssh with kerberos
#+BEGIN_EXAMPLE
/etc/ssh/sshd_config

GSSAPIAuthentication yes
GSSAPICleanupCredentials yes

Host *
  GSSAPIAuthentication yes
#+END_EXAMPLE

- =kinit -f=
- ssh and transfer forwardable credentials: =ssh -o GSSAPIDelegatecredentials=yes targetserver=
- logout from ssh: =~.=
*** Securing the Filesystem
**** Mount Options
- =noexec= mount option on user-writable directories. At a minimum,
  =nosuid=, =nodev= for removable media.
  - attack vector: create a =suid= =root= binary on a removable media,
    mount and execute on target system.
    - Exercise: copy /bin/bash to usb stick and =chmod 6755=
  - variation (exercise): create a device file referencing the root
    FS, and escalate through that
**** NFS
- similar attack vectors to removeable media: if a user has =root= on
  an NFS client, they can create =suid root= executables on the mount
  and try executing them on another machine to escalate.
- restrict allowable client list in =/etc/exports=
- root squashing is default: client =uid= 0 is automatically remapped
  to e.g. =nobody= on the server. Configurable with =anonuid/anongid=
  options. Can be disabled with =no_root_squash=. =all_squash= can be
  used to remap all access.
- =insecure= option allows access from clients bound to high port
  numbers. Does not really decrease security.
- Lab: examine mounted filesystems and correct mount options for
  better security:
  - e.g. /boot, /tmp, /usr, /var, /dev/shm
  - verify:
    - e.g. =mknod -m 777 /var/disk b 3 0= should fail
- Lab: create and exploit insecure =NFS= export
  - =/export/insecure 1.0.0.0/1(no_root_squash,rw,sync)= in =/etc/exports=
  - on a client, mount it and create a root-owned =suid= binary, eg. =vim= or =bash=
  - then execute the =suid= binary on the server or another client
- Lab: create a more secure export on the server and show it doesn't
  allow the =suid= or =mknod= exploit by the client. However, show the
  *client is still vulnerable to exploit by the server*. Correct mount
  options on the client to remedy.
***** NFSv4
- user names instead of =uid= numbers used by protocol to identify the
  users. No need to have =uids= match on both client and server.
- =rpc.statd=, =rpc.mountd=, =rpc.rquotad=, =rpc.lockd= no longer needed
- /pseudo-root/ exported via =/etc/exports=:
  =/srv/export  *(rw,fsid=0,no_subtree_check,async)=
  =fsid=0= (or =fsid=root=) declares the export to be the root of all exported
  filesystems
- =GSSAPI= to /mutually/ authenticate server and client to each other
  - =rpc.idmapd= daemon does the translation on both client and server
    - =/etc/idmapd.conf=
  - need =nfs/FQDN@REALM= keys for both client and server
  - integrity checking and encryption of NFS traffic
  - =rpc.svcgssd= on the server and =rpc.gssd= on the client
    - on RHEL, enable via =SECURE_NFS=yes= in =/etc/sysconfig/nfs=
    - need =prcsec_gss_krb5= kernel module to be loaded
  - require =GSSAPI= in =/etc/exports=
    - =/srv/export1  gss/krb5(rw,fsid=0,no_subtree_check,sync)=
    - =gss/krb5= for host and user auth
    - =gss/krb5i= to require integrity checking of NFS traffic
    - =gss/krb5p= to require encryption of all NFS traffic
  - to mount kerberos-protected exports, use
    =mount -t nfs4 -osec=krb5p server:/srv/export1 /mnt/=
- Lab: experiment with NFS and GSSAPI
  - create an NFSv4 export with 3 subdirectories, each owned by a
    different user, and =chmod= 700
    =/srv/export  10.0.0.0/8(fsid=0,rw,no_subtree_check,sync)=
  - observe that NFSv2/v3 mount of the export should fail
  - require GSSAPI auth for NFS and restart NFS daemons
  - require =gss/krb5i= on the export and re-export with =exportfs -r=
  - try mounting without GSSAPI or without requiring integrity
    protection: =mount -t nfs4 server:/ /mnt= or =mount -t nfs4 -osec=krb5 server:/ /mnt=
  - now try mounting with integrity protection:
    - =mount -t nfs4 -osec=krb5i server:/ /mnt=
  - try listing directory of a different user: =ls /mnt/userB=
  - now try creating =userB= on the client and =su= to it:
    - =su - userB=
    - =ls /mnt/userB=
    - should still fail since local =userB= does not possess the
      required kerberos ticket
  - now obtain the kerberos ticket as =userB= and access the directory:
    =kinit userB=
    =ls -la /mnt/userB=
***** GPG and openSSL
- GPG
  - generate keypair: =gpg --gen-key=
  - encrypt file: =gpg -e filename=
  - encrypt with symmetric password: =gpg -c filename=
  - decrypt (both symmetric and asymmetric): =gpg -d filename=
  - sign file: =gpg -s filename=
  - cleartext signature: =gpg --clearsign filename=
  - verify signature: =gpg --verify filename=
  - configuration via =~/.gnupg=
    - =no-greeting=: don't show copyright notice
    - =defaut-key key1=
    - =keyserver hkp://subkeys.pgp.net=
  - =secring.gpg= The secret keyring
  - =pubring.gpg= public keyring
  - =trustdb.gpg= the trust database
  - GPG agent
    - =gpg-agent --daemon --enable-ssh-support --write-env-file ~/.gpg-agent-info=
- openSSL
  - =openssl enc -bf -a -in inputfile -out outputfile=
    - =-enc=: ecrypt
    - =-bf=: use BlowFish
    - =-a=: output =base64= encoded stream
    - decrypt with =openssl enc -d -bf -a -in inputfile -o outputfile=
  - network client: =openssl s_client -host www.example.com -port 443=
- Lab: generate gpg keypair. start gpg-agent. encrypt/decrypt file with gpg.
- Lab: encrypt and decrypt a file using openssl. Encrypt a tarball,
  then compress with xz. Repeat with compressing first, then
  encrypting
***** encfs
- implemented on top of =FUSE=
- =encfs ~/.encrypted_backend ~/decrypted=
- encrypts individual files, not block devices
- encfs backend can be shared by different users, each of whom will
  only see the files encrypted by their own password
***** LUKS
- implemented on top of device-mapper
  - see =dm-crypt= and =dm-mod= kernel modules
  - =cryptsetup= porcelain layer on top of =dmsetup=
- =cryptsetup --verify-passphrase luksFormat /dev/vg/lv_encrypted=
- =cryptsetup luksOpen /dev/vg/lv_encrypted crypt=
  - will create a =dm= block device =crypt=
  - =mkfs.ext4 -L crypt /dev/mapper/crypt=
- prompt decrypt on mount:
  - =crypt /dev/vg/lv_encrypted= in =/etc/crypttab=
  - =/dev/mapper/crypt   /path/to/mountpoint   ext4   defaults 1 2= in =/etc/fstab=
- Lab: create and format a LUKS filesystem. Set up multiple keys to access it
  - =cryptsetup luksClose /dev/mapper/crypt=
***** Extended Attributes and ACLs
=tune2fs -c 0 -i0 -o acl,user_xattr /dev/vg/lv=
*** SELinux
**** DAS vs MAC
- DAC: discretionary access control, in the sense that a /subject/
  with certain access permission is able to pass that permission,
  perhaps indirectly, on to another subject
- most system resources are represented as files, wich are owned by a
  user and a group. Permissions are assigned to the files to determine
  the level of access for the owner, members of the owning group, and
  others.
- the owner can grant access at their discretion, and otherwise has
  full control over the file
- MAC: mandatory access control; a designated security administrator
  sets up access policies, based on which the system makes access
  decisions
- traditional UNIX security: historically, uid 0 (root) has 'god
  power' on the system. This means processes running as root typically
  have more privileges than they need
- POSIX capabilities carve out specific privileges that can be
  abrogated by a process to reduce the damage should it become
  compromised
- =suid/sgid=: a process is launched with the uid/gid of the /object/
  (the executable file) rather than the subject (user) who launches
  it. Classic example: =ping= needs to write IP packets, which is not
  available via unprivileged TCP/UDP API. Historically, =ping= was
  =suid= =root= until it was rewritten to use =POSIX= caps
- processes in the same security context have no limit on interaction:
  they can send signals to each other, e.g. SIGKILL. Segmenting by
  uid/gid is often too coarse. E.g. a CGI script launched by a web
  server will have security context of the web server and thus the
  same level of access to the system
**** LSM
- Linux Security Module, created as a shim between NSA SElinux and the
  rest of the kernel to give reusable abstraction
**** AppArmor
- an LSM (Linux sec module)
**** SELinux
- goals: security administrator specifies policy, to be enforced by
  the kernel
  - policy allows the expected interactions within the system
  - original NSA security policy:
    - control raw access to data
    - protect integrity of the kernel
    - protect integrity of system software, system config, system logs
    - confine damage from exploit on a privileged process
    - protect privileged processes from executing malicious code
    - protect admin role and domain from being entered without
      authentication
    - prevent user processes from interfering with system processes or
      admin processes
    - protect users from exploits in the web browser by malicious code
- modes
  - enforcing and permissive
    - =setenforce 0/1=; =getenforce=, =sestatus=
- basic information about the state of selinux
  - =sestatus=, =sestatus -v= will give a list of contexts
    - =/etc/sestatus.conf=
- SELinux VFS
  - =/selinux/enforce=
  - =/selinux/avc=
  - =/selinux/booleans=
  - =/proc/pid/attr/*= - security context of the process
**** Type Enforcement (TE) Security Model
- every object (file, process, ...) is assigned a type label. A type
  applied to a process is called a domain. Security policy defines the
  allowed interaction between domains and types.
- TE is the core enforcement model of the RH targeted policy
- RBAC security model
  - Users are assigned roles. A mechanism is needed to allow the user
    to transition between the allowed roles.
  - SELinux =newrole= command
  - Traditionally, system privileges are assigned directly to the
    various roles. With SElunux, each role is assigned a list of
    domains that may exist in it.
- Security Context (aka label) consist of 3 components:
  - identity: the owner of the object. =user_u= is the fallback
    default identity for UNIX accounts not explicitly mapped to an identity
  - role: for processes, the domain of the process. For files, a
    placeholder value =object_r=
  - type: classification of the object as to its specific security needs
  - security_level: of the form =sX-sY:cY-cY=
    - =sX= is the sensitivity level =s0-s15=
    - =cY= is the (optional) category =c0-c255=
  - =chcon=, =restorecon=, =/.autorelabel=
- Policies
  - RHEL SELinux policies
    - targeted policy: =unconfined_t=, =kernel_t=, =initrc_t=
      unrestricted domains
    - MLS policy: based on security levels and categories. LSPP, RBAC,
      and CAPP certification at EAL 4+. Mostly used in military or
      government deployments
    - Minimum policy: subset of the targeted policy
    - reference policy: original policy from NSA. Now by Tresys
      Technology
  - switching policies
    - =/etc/selinux/config=: =SELINUXTYPE=mls/minimum/targeted=
  - Policy Config Files
    - policy source, single binary policy (policy.XX), modular binary
      policy files (application.pp)
    - =/etc/selinux/=
      - =srtict=
        - =contexts=
        - =modules=
          - =active=
            - =modules=
              - =app1.pp=
              - =app2.pp=
          - =policy/policy.24=
      - =targeted=
        - =contexts=
        - ...
    - =apol= tool
- Booleans: toggle certain SELinux rules
  - =man -k _selinux= -> ... =httpd_selinux (8)=
  - visible in =/selinux/booleans=. Also =getsebool=. Also =semanage
    boolean -l=
  - changing in two stages: set and commit
    - via =echo 1 > /selinux/commit_pending_bools=
    - also =togglesebool= and =setsebool=. persistent with =-P=
  - =disable_trans= booleans
    - selectively disable transition to a confined
      domain. e.g. =httpd_disable_trans= keeps Apache running in
      =initrc_t= domain rather than transition to =httpd_t=. Caveat:
      files created by the service would be mislabelled. Not
      recommended.
- Permissive Domains
  - disable policy enforcement for a specific domain. The rest of the
    system is still protected by SELinux.
  - =semanage permissive -a <domain>=
  - =semodule -l | grep permissive=
  - restore confinement: =semanage permissive -d <domain>=
- Managing File Contexts
  - default context associates with every file
    - =semanage fcontext -l= lists the mappings of regexps matching on
      file path + file type to context
    - =semanage fcontext -a= to add a mapping:
      - =semanage fcontext -a -t httpd_sys_content_t '/myweb(/.*)?'=
- Managing port contexts
  - =semanage port -l=
- Lab: apply incorrect context to httpd document root
  - observe HTTP 403 error, and AVC error messages in the audit log
  - restore context
- Lab: toggle httpd_enable_cgi to off
  - install a simple cgi script, observe it run from command line
  - observe http 403 error and apache error log
  - =aureport --avc --failed -ts recent= to get report numbers
  - =ausearch -a report_number=
  - =sesearch --allow -s httpd_t -t httpd_sys_script_exec_t -p getattr -C=
  - toggle sebool back to on and observe CGI script run
**** Examining Policy
  - =seinfo=
  - =sesearch= to display policy statements matching a search
    - =sesearch -A -s httpd_t= will list all AV rules involving =httpd_t=
    - =sesearch -A -s httpd_t -c file -p read -C= all files =httpd_t= can read
    - =sesearch -A -t shadow_t -c file -p write -C=
    - =sesearch -b allow_httpd_anon_write -A -C= what does =allow_httpd_anon_write= enable?
    - =sesearch -A -s httpd_t -c tcp_socket -p name_bind -C=  what ports can =httpd_t= bind to?
**** SELinux Troubleshooting
- =auditd= is your friend: =/var/log/audit/audit.log=
- some denials are not logged due to =dontaudit= policy
  statements. Override with =semodule -DB= =semodule -b /usr/share/selinux/targeted/enableaudit.pp=
  - return to normal with =semodule -B= =semodule -b /usr/share/selinux/targeted/base.pp=
- =setroubleshootd=
- =sealert=
- fix file contexts with =chcon= or =restorecon=
- directories that need to be used by multiple services:
  =public_content_t=, =public_content_rw_t=
- allow service to bind to alternative port with =semanage port -a -t httpd_port_t -p tcp 8080=
**** audit2allow
Lab: create x509 certificate for dovecot with wrong type,
e.g. =httpd_sys_content_t=.
- =tail /var/log/audit/audit.log=
- copy denial messages from audit.log and feed them to =audit2allow=
  =audit2allow -M dovecotextra < dovecot_failures.log=
- =semodule -i dovecotextra.pp=
- examine the type enforcement (.te) produced by =audit2allow=
  #+BEGIN_EXAMPLE
  module dovecotextra 1.0;
  require {
    type postfix_etc_t;
    type httpd_sys_content_t;
    class file read;
  }
  allow dovecot_t httpd_sys_content_t:file read;
  #+END_EXAMPLE
- =semodule -l | grep dovecotextra=
- cleanup: =semodule -r dovecotextra=
- proper fix: =chcon -t cert_t /path/to/x509/cert=
**** Creating and Compiling policy from source
create policy module
#+BEGIN_EXAMPLE
policy_module(mypostfix_dovecot, 1.0)

gen_require('
  type postfix_t, dovecot_t;
')
type postfix_dovecot_cert_t;
files_type(postfix_dovecot_cert_t)

read_files_pattern(postfix_t, postfix_dovecot_cert_t, postfix_dovecot_cert_t)
read_files_pattern(dovecot_t, postfix_dovecot_cert_t, postfix_dovecot_cert_t)
#+END_EXAMPLE

create new file contexts file to make relabelling easier:

#+BEGIN_EXAMPLE
/etc/pki/tls/certs/*/email.*    gen_context(system_u:object:r:postfix_dovecot_cert_t,s0)
/etc/pki/dovecot/*/email.*    gen_context(system_u:object:r:postfix_dovecot_cert_t,s0)
#+END_EXAMPLE

=semodule -i mypostfix.pp=
=semodule -l | grep mypostfix=
=restorecon -v /etc/pki/dovecot/*/email.pem=

#+title: Enterprise Linux Security Administration
*** Security Concepts
- Minimization
  - every installed component is a security risk, no such thing as
    innocuous service
    - every running component doubly so
      - services are no longer configured to start on boot by install
        scripts
  - discovery
    - packaged software
      - =rpm -qa=: all packages installed on system
      - =rpm -qi pkg=: info about package =pkg=
      - =rpm -ql pkg=: all files provided in package
      - =rpm -qf file=: which package provided the file
      - =rpm -qlp pkg.rpm=
      - lab (~5 mins)
        - objectives
          - use =rpm= do discover what packages are installed
          - trace dependency chain
        - tasks
          - list all packages installed
          - how many are there?
          - which package does =/usr/bin/openssl= belong to?
          - what packages require that package as dependencies?
          - now remove the packages in question
          - is this it?
            - =rpm -q --whatrequires $(rpm -q --provides openssl) | sort -u=
          - are we done now?
            - what do the packages we removed provide, and what
              depends on *that*?
    - unpackaged software
      - =find /where -user userid -exec rm {} \;=
      - =-ok= is like =-exec= but asks first
    - running processes
      - =chkconfig=
      - =netstat -taupe=
      - =ss -taupe=
      - =ps auxw=
      - =lsof -i=
      - lab (~5 minutes)
        - objectives
          - identify running processes
          - disable and uninstall unneeded software
        - tasks
          - which processes are configured to start at boot?
          - disable =avahi=, =bluetooth=, =xinetd= from starting on boot
          - what is listening on network?
            - =ss -taupe | grep LISTEN=
            - =lsof -i=
          - remove =xinetd= from the system
            - =rpm -e=
- Hardening
  - Already need a picture of who is going to access the service and
    what level of access they need
  - Do not trust default config!
  - Simplify!
  - packet filtering
    - pre-firewalld
      - config persists in =/etc/sysconfig/ip{,6}tables=
    - firewalld
  - service wrapping
    - =xinetd=
  - Authentication
    - PAM
      - shortcomings of PAM
  - minimizing service capabilities
    - least-privilege principle
    - =setuid=
    - POSIX 1003.1e capabilities
      - =capability.h=
      - =libcap=
        - =sucap=, =execcap=, =getpcaps=, =setpcaps=
      - lab 10 minutes
        - objectives
          - examine use of =capset()= and =setuid()= system calls
        - tasks
          - make sure =ntpd= is installed and running
          - what are the real and effective credentials of the =ntpd= process?
            - =ps -C ntpd -o comm,pid,ruser,euser,rgroup,egroup=
            - how does user =ntp= bind to port =tcp 123=, and how can
              it change system clock?
          - restart =ntpd= with tracing:
            - =strace -f ntpd -u ntp:ntp -g 2> ntp-calls &=
            - =grep -n bind ntp-calls | grep AF_INET=
            - =grep -n -B 5 capset ntp-calls=
              - which capabilities does it retain?
              - how does it change its effective user & group?
            - =grep -e [UG]id -e ^Cap /proc/$(pgrep ntpd)/status=
              - look for =Uid, Gid, Cap{Inh,Prm,Eff}=
    - =chroot=
      - lab 10 minutes
        - objectives
          - examine security implications of =chroot()=
        - tasks
          - install =busibox=
          - copy busibox and bash to =/tmp/jail=
          - =ldd *=, copy libraries to =/tmp/jail/lib=
          - =chroot /tmp/jail/bash=
          - =ls= does not exist!
          - use commands provided by =busybox=
          - from outside the jail, run =ls -la /proc/$(pgrep -xf /bash)/{cdw,root}=
      - SELinux is better!
        - no need to maintain multiple copies of software
*** Scanning, Probing, and Mapping Vulnerabilities
- The Security Environment
  - Reconnaissance
    - public info
      - information never dies
      - profiling from public forums
      - WHOIS database
        - admin and technical contacts
        - netblock maintainer of the IP address
      - DNS
        - reverse lookup on target's IP address
          - why stop at one address? try nearby ones as well!
        - zone transfers
          - bulk transfer of all DNS entries in a zone
            - =host -l example.com=
    - discovery
      - =ping=
      - flood ping =fping=
      - =nmap=
        - ping sweep =nmap -sP 192.168.0.0/16=
          - if ICMP echo is filtered, try ICMP timestamp, or TCP
            connection to well-known ports
            - www.iana.org/assignments/port-numbers
            - /etc/services
        - IP stack and service fingerprinting
          - =nmap -sV -O target.example.org=
        - Lab (30 mins)
          - objectives
            - use =nmap= to discover and fingerprint services
          - tasks
            - install =wireshark=
            - ping scan of local network
              - =nmap -v -sP 192.168.0.0/24=
            - run ping scan again while running pcap:
              - =tshark -n=
              - what is the output?
            - run TCP connect() scan:
              - =nmap -sT target=
                - what flags are set in the scan packet?
                  - in the response for listening ports?
                  - closed ports?
              - decoy hosts
                - =nmap -sS -D decoy1,decoy2 target=
                - what will decoys see?
            - try =-f= option to fragment packets, see tshark output
            - try null and xmas scans
      - SNMP
        - UDP port 161 and 162 (snmptrapd)
        - =snmpnetstat -v2c -c public -Cr 192.168.32.2=
          - =-r= requests routing table
          - =-a= shows all socket info
        - =snmpwalk -c public -v2c 192.168.32.2=
      - RPC
        - portmapper listens on TCP port 111
        - applications select a free port to listen on, and register
          themselves with portmapper
          - =rpcinfo -p target.example.com=
          - =nmap= can still identify RPC applications even if it
            can't reach portmapper
      - enumerating NFS shares
        - =showmount -e target=
          - =-e= lists exports, =-a= shows active mounts
    - Insecurity Scanners
      - Nessus/ openVAS
        - NASL, Nessus Attack Vulnerability Language
          - update rules with =openvas-nvt-sync=
          - agent/server model
          - lab?: install openvas, tshark while it's running
  - Exploit Services
    - www.securityfocus.com
  - install backdoor
    - escalate privileges
    - rootkit
  - cover tracks
    - logsweeps
*** Password Security and PAM
- local vs network passwords: =/etc/nsswitch=
- =/etc/passwd= -> =/etc/shadow=: =pwconv=
- trapdoor function: hashing
  - =crypt()=: DES encryption of password with itself as key (?)
    - weak!
  - =md5=, =bcrypt=, =sha256=, =sha512=
- password ageing
  - =/etc/shadow=: =chage=
- auditing passwords
  - John the ripper from openwall project
    - checkpointing: =session:FILE=, =-restore=
    - wordlists
    - Lab: use JTR to audit passwords
      - install JTR
      - =john -test=
      - create new user and set a password
      - unshadow the password file: =unshadow /etc/{passwd,shadow} > /tmp/passwords=
      - =john /tmp/passwords=
      - download wordlist and use it to seed JTR
        - =john -wordlist:morewords /tmp/passwords=
      - recompile a new master wordlist on the system
  - PAM
    - =/etc/pam.d=
    - is PAM support linked into the binary?
       =ldd /usr/sbin/sshd | grep libpam=
    - PAM Services (module types)
      - auth
        - authentication: verify identity, grant group memberships
      - account
        - authorization: is the user allowed to use this service at this moment?
      - password
        - used for password changes
      - session
        - executes code at start/end of a session. E.g. =ulimit=
    - a given module can provide more than one type:
      e.g. =pam_unix.so= can be invoked as any of the four types.
    - program checks its own PAM config file in =/etc/pam.d=, falls back to =other=
    - =include= statement to reduce code duplication
    - top-down processing, flow control statements in config
      - =required=
        - fails the stack, but processing continues
      - =requisite=
        - fails the stack, processing terminates
      - =sufficient=
        - passes the stack unless previous module failed it. processing terminates
      - =optional=
        - no decision on stack success
    - module menagery
      - ls =/lib/security=
      - =pam_unix=
        - refers to Name Service Switch to determine auth backend
        - can e.g. obtain kerberos ticket before session opened
        - password ageing, session logging
        - =use_first_pass= vs =try_first_pass=
      - =pam_pwcheck=
        - password strength enforcement
      - =pam_xauth=
        - transfers =X= cookies e.g. after =su=
        - =.Xauthority=
          - =~/.xauth/{import,export}= controls from/to which users
            this user can share cookies
      - =pam_tally2=
        - keep list of failed logins, can lock out
      - =pam_wheel=
        - policy on who can =su= to =root=
      - =pam_nologin=
        - if =/etc/nologin= exists, no non-root user can login
      - =pam_deny=
        - denies everything, secure default to terminate every stack
      - =pam_warn=
        - forces logging
      - =pam_securetty=
        - forces =root= to login through a 'secure' TTY, as listed in =/etc/securetty=
      - =pam_time=
        - enforces policy of which services will allow which users during which times through which ttys
      - =pam_access=
        - restricts access based on the location:
          =/etc/security/access.conf=: =permissions: users: origins=,
          where =origins= lists TTYs or hostnames
        - Lab: restrict user access from specified IPs
          - =/etc/pam.d/sshd=
            - =account required pam_access.so=
          - =/etc/security/access.conf=
            - =-:testuser1:ALL EXCEPT station1.example.com=
      - =pam_listfile=
        - arbitrary text files as a source of access control. Specify
          sense (allow/deny), item: user, tty, rhost, ruser, group,
          shell
        - Lab: restrict ssh access to a list of authorized users with
          =pam_listfile=
          - =/etc/pam.d/sshd=:
            - =auth required pam_listfile.so sense=allow item=user file=/etc/ssh_permit=
      - =pam_lastlog=
        - display time and location of last login. Taken from
          =/var/log/lastlog=
      - =pam_console=
        - set privileges on local tty differently from remote
          access. =/etc/security/console.perms=.
*** Securing NTP
- =hwclock=
- =date=
- NTP terms
  - resolution
    - smallest interval measurable by clock
  - precision
  - jitter
  - accuracy
  - frequency error
  - reliability
  - wander
- synchronization services
  - Digital Time Sync Service (DTSS)
  - NTP: RFC 958(v0), 1059(v1), 1119(v2), 1305(v3)
- NTP v4
  - client-server & broadcast
    - multicast on 224.0.1.1, ff05::101
  - server hierarchy
    - stratum 0,1,2,..15
- =ntpdate=
  - slew vs jump update
- =ntpd=
  - multicastclient/broadcastclient
  - =broadcast 244.0.1.1= for multicast
  - driftfile
  - panic threshold
- =ntp.conf=
  - =restrict ntp1.example.com nomodify=
    - trust the time from =ntp1= but disallow it from modifying
      configuration
  - =restrict 172.16.1.0 mask 255.255.255.0 nomodify noquery=
- NTP integrity
  - symmetric encryption support in NTPv3 and v4
    - =/etc/ntp.conf=:
      - =keys   /etc/ntp/keys=
  - NTPv4 also supports 'autokey' (public key) encryption
    - =/etc/ntp.conf=:
      - =crypto /path/to/cert /path/to/rsa_key=
- =ntpq=
- =ntpc=
- =ntptrace=
- =ntpstat=
*** Kerberos
**** Concepts and Components
- 'crustacean' model of network security: fortify the perimeter and
  trust the internal network
- RFC 1510
- central trusted server, KDC, that authenticates and issues tickets
- authentication only, authorization is up to the service
- principals:
  - name, e.g. =user/admin@EXAMPLE.ORG=, has 3 components:
    - primary: =user=. For services, indicates service type,
      e.g. =host/= or =ldap/=
    - instance: mandatory for service principals. For users, usually
      used to modify capabilities given to the principal
    - realm: =EXAMPLE.ORG=
- session replay protection
  - each ticket carries a sequence number
  - sequence numbers do no roll over in the validity window, usually 5
    mins
- Kerberos Components
  - Authentication Server (AS)
  - Ticket-Granting Servier (TGS)
  - kerberized services using KDC
- GSSAPI
- SASL
**** Authentication Process
#+BEGIN_SRC plantuml :file tmp/krb5_auth_process.png :cache yes
@startuml
"Client Workstation" --> "Authentication Server": obtain tgt
"Authentication Server" --> "Client Workstation": obtain sgt for service 1
"Client Workstation" --> "Kerberized Service 1": use sgt for service 1
"Client Workstation" --> "Authentication Server": obtain sgt for service 2
"Client Workstation" --> "Kerberized Service 2": use sgt for service 2
@enduml
#+END_SRC
**** ticket attributes
- kerberos version + realm, unencrypted
- principal of the service, unencrypted
- principal of the user, unencrypted
- IP address of client host
- issued timestamp
- expiry timestamp
- session key to encrypt communication between client and service
**** Authenticators
encrypted with tgt, opague for the client
contains
- Client's principal
- hash of the ticket
- timestamp issued
- sequence number to prevent replay attacks
**** logging in
- obtain TGT. Optionally, AS can be set to require a pre-authenticator with the tgt request
- the pre-authenticator is salt + timestamp encrypted with the principal's password
- prevents brute-force attacks on krb AS service
**** TGT request
- pre-authenticator
- message type = 10
- timestamps
- flags
- user principal
**** TGT response
- message type = 11
- user principal
- encrypted with the user principal's key
  - timestamps
  - flags
  - client IP(s)
  - server TGS principal
  - session key
- encrypted with TGS key
  - TGS principal
  - timestamps
  - client IP(s)
  - user principal
  - session key
**** SGT request
- request body
  - message type = 12
  - timestamps
  - flags
  - client IP(s)
  - supported enctypes
- TGT ticket, encrypted with TGS key
  - copied verbatim from TGT
- authenticator, encrypted with session key
  - user principal
  - hash of request body
  - timestamps
  - sequence number
**** SGT response
- message type = 13
- user principal
- encrypted with user principal's key
  - timestamps
  - flags
  - client IPs
  - service principal
  - sub-session key
- SGT, encrypted with service's secret key
  - service principal
  - timesamps
  - flags
  - client IPs
  - user principal
  - sub-session key
**** Service Access Request
- request body
  - message type = 14
  - mutual auth request
- service ticket: copied from SGT
- authenticator, encrypted with session sub-key
  - user principal
  - hash or request body
  - timestamps
  - sequence number
**** Mutual Authentication Response
- message type = 15
- encrypted with session subkey
  - timestamps
  - sequence number
**** Kerberos Components
- KDC
  - Authentication Service (AS)
  - Ticket-Granting Service (TGS)
- kerbrized services
  - telnet
  - ftp
  - rsh/rlogin/rcp
  - ssh
  - ksu
  - thunderbird
  - firefox
  - ssh
  - printing
  - imap/pop/smtp
  - web server
  - nfs
  - afs
**** kerberos setup
***** KDC
- krb5kdc
- kpropd
- kadmind
***** utilities
- master KDC
  - kdb5_util
  - kprop
- admin clients
  - kadmin
  - ktutil
- principal
  - kinit
  - pam_krb5
  - klist
  - kdestroy
  - kpasswd
**** kerberos daemon + utility relationships
kprop on kdc master -> kpropd on kdc slaves
kamdin on client -> kadmind on master kdc
kinit on client  -> krb5kdc on kdc (master or slave)
**** administering and using kerberos
***** configuring master KDC

#+BEGIN_EXAMPLE /etc/kdc.conf
[kdcdefaults]
kdc_ports = 88
kdc_tcp_ports = 88

[realms]
EXAMPLE.COM = {
  acl_file     = /var/kerberos/krb5kdc/kadm5.acl
  dict_file    = /usr/share/dict/words
  admin_keytab = /var/kerberos/krb5kdc/kadm5.keytab
  supported_enctypes = aes256-cts:normal
}
#+END_EXAMPLE
***** KDC logging

Three types of data to be logged:
- default
- kdc: KDC logs
- admin_server

five possible destinations:
- FILE:filename: log to file
- STDERR: log to standard error
- CONSOLE: log to system console
- DEVICE=devicename: log to specified device
- SYSLOG:[severity:facility]: log to syslog

#+BEGIN_EXAMPLE /etc/krb5.conf
[logging]
kdc=CONSOLE
kdc=SYSLOG:NOTICE:DAEMON
admin_server=FILE:/var/log/kadmin.log
#+END_EXAMPLE

***** KDC realm defaults

- libdefaults: defaults for all krb libraries
- appdefaults: defaults for specific client apps
- realms: realms used by client
- domain_realm: map DNS domain names -> realm names
- logging: kerb client logging
- capaths: x-realm authentications

#+BEGIN_EXAMPLE
[libdefaults]
default_realm = EXAMPLE.COM
dns_lookup_realm = false
dns_lookup_kdc   = false
ticket_lifetime  = 24h
renew_lifetime   = 7d
forwardable      = yes
#+END_EXAMPLE

#+BEGIN_EXAMPLE
[realms]
EXAMPLE.COM = {
  kdc = server1.example.com
  kdc = server2.example.com
  admin_server = server1.example.com
}
#+END_EXAMPLE

***** DNS autoconfig
#+BEGIN_EXAMPLE
$ORIGIN example.com

_kerberos              TXT   "EXAMPLE.COM"
_kerberos._udp         SRV   0 0 88 server1.example.com
                       SRV   0 0 88 server2.example.com
_kerberos-master._udp  SRV   0 0 99 server1.example.com
_kerberos-adm._tcp     SRV   0 0 749 server1.example.com
_kpasswd._udp          SRV   0 0 464 server1.example.com
#+END_EXAMPLE
***** keytabs
- keytab for =kadmind= on RHEL is in =/var/kerberos/krb5kdc/kadm5/keytab=
- fetch keys and save in keytabs with MIT kerberos: =kadmin=
  - =getprinc=, =list_principals=, etc
- read and modify local keytabs: =ktutil=
***** ticket types
- initial: issued directly to principal. non-initial are granted on
  the basis of another ticket
- forwardable
- proxiable: used by services to authenticate on behalf of principals
- renewable
- postdatable: validity of tickets starts in the future. used e.g. by
  cronjobs
- invalid: used e.g. by postdated tickets before they are valid
***** managing principals
attributes
| allow_forwardable |
| allow_postdated   |
| allow_proxiable   |
| requires_preauth  |
| requires_hwauth   |
| allow_svr         |
| allow_tix         |
| needschange       |
***** principal policies
- maxlife
- minlife
- minlife
- minlength
- minclasses
- history
***** securing workstation login
use =*K*= in =/etc/shadow= to indicate the principal should
authenticate via kerberos. e.g. =useradd -p "*K*" user=

on RHEL6, the pam config bypasses obtaining kerberos ticket if unix
password is set:
#+BEGIN_EXAMPLE pam_config
auth sufficient pam_unix.so try_first_pass
auth sufficient pam_krb5.so use_first_pass

- =ksu= command:
  - =~/.k5login= lists principals allowed to log in as that user
  - "kerberized sudo": =~/.k5users= specifies which kerberos principal is allowed to execute specific commands
#+END_EXAMPLE
***** forwarding kerberos tickets
- non-forwardable TGT =kinit -F=
- =telnet -x= to have telnet try to use krb5. it's the default with
  newer versions onf telnet
- =telnet -xF= will forward local credentials to the remote system
***** securing ssh with kerberos
#+BEGIN_EXAMPLE
/etc/ssh/sshd_config

GSSAPIAuthentication yes
GSSAPICleanupCredentials yes

Host *
  GSSAPIAuthentication yes
#+END_EXAMPLE

- =kinit -f=
- ssh and transfer forwardable credentials: =ssh -o GSSAPIDelegatecredentials=yes targetserver=
- logout from ssh: =~.=
*** Securing the Filesystem
**** Mount Options
- =noexec= mount option on user-writable directories. At a minimum,
  =nosuid=, =nodev= for removable media.
  - attack vector: create a =suid= =root= binary on a removable media,
    mount and execute on target system.
    - Exercise: copy /bin/bash to usb stick and =chmod 6755=
  - variation (exercise): create a device file referencing the root
    FS, and escalate through that
**** NFS
- similar attack vectors to removeable media: if a user has =root= on
  an NFS client, they can create =suid root= executables on the mount
  and try executing them on another machine to escalate.
- restrict allowable client list in =/etc/exports=
- root squashing is default: client =uid= 0 is automatically remapped
  to e.g. =nobody= on the server. Configurable with =anonuid/anongid=
  options. Can be disabled with =no_root_squash=. =all_squash= can be
  used to remap all access.
- =insecure= option allows access from clients bound to high port
  numbers. Does not really decrease security.
- Lab: examine mounted filesystems and correct mount options for
  better security:
  - e.g. /boot, /tmp, /usr, /var, /dev/shm
  - verify:
    - e.g. =mknod -m 777 /var/disk b 3 0= should fail
- Lab: create and exploit insecure =NFS= export
  - =/export/insecure 1.0.0.0/1(no_root_squash,rw,sync)= in =/etc/exports=
  - on a client, mount it and create a root-owned =suid= binary, eg. =vim= or =bash=
  - then execute the =suid= binary on the server or another client
- Lab: create a more secure export on the server and show it doesn't
  allow the =suid= or =mknod= exploit by the client. However, show the
  *client is still vulnerable to exploit by the server*. Correct mount
  options on the client to remedy.
***** NFSv4
- user names instead of =uid= numbers used by protocol to identify the
  users. No need to have =uids= match on both client and server.
- =rpc.statd=, =rpc.mountd=, =rpc.rquotad=, =rpc.lockd= no longer needed
- /pseudo-root/ exported via =/etc/exports=:
  =/srv/export  *(rw,fsid=0,no_subtree_check,async)=
  =fsid=0= (or =fsid=root=) declares the export to be the root of all exported
  filesystems
- =GSSAPI= to /mutually/ authenticate server and client to each other
  - =rpc.idmapd= daemon does the translation on both client and server
    - =/etc/idmapd.conf=
  - need =nfs/FQDN@REALM= keys for both client and server
  - integrity checking and encryption of NFS traffic
  - =rpc.svcgssd= on the server and =rpc.gssd= on the client
    - on RHEL, enable via =SECURE_NFS=yes= in =/etc/sysconfig/nfs=
    - need =prcsec_gss_krb5= kernel module to be loaded
  - require =GSSAPI= in =/etc/exports=
    - =/srv/export1  gss/krb5(rw,fsid=0,no_subtree_check,sync)=
    - =gss/krb5= for host and user auth
    - =gss/krb5i= to require integrity checking of NFS traffic
    - =gss/krb5p= to require encryption of all NFS traffic
  - to mount kerberos-protected exports, use
    =mount -t nfs4 -osec=krb5p server:/srv/export1 /mnt/=
- Lab: experiment with NFS and GSSAPI
  - create an NFSv4 export with 3 subdirectories, each owned by a
    different user, and =chmod= 700
    =/srv/export  10.0.0.0/8(fsid=0,rw,no_subtree_check,sync)=
  - observe that NFSv2/v3 mount of the export should fail
  - require GSSAPI auth for NFS and restart NFS daemons
  - require =gss/krb5i= on the export and re-export with =exportfs -r=
  - try mounting without GSSAPI or without requiring integrity
    protection: =mount -t nfs4 server:/ /mnt= or =mount -t nfs4 -osec=krb5 server:/ /mnt=
  - now try mounting with integrity protection:
    - =mount -t nfs4 -osec=krb5i server:/ /mnt=
  - try listing directory of a different user: =ls /mnt/userB=
  - now try creating =userB= on the client and =su= to it:
    - =su - userB=
    - =ls /mnt/userB=
    - should still fail since local =userB= does not possess the
      required kerberos ticket
  - now obtain the kerberos ticket as =userB= and access the directory:
    =kinit userB=
    =ls -la /mnt/userB=
***** GPG and openSSL
- GPG
  - generate keypair: =gpg --gen-key=
  - encrypt file: =gpg -e filename=
  - encrypt with symmetric password: =gpg -c filename=
  - decrypt (both symmetric and asymmetric): =gpg -d filename=
  - sign file: =gpg -s filename=
  - cleartext signature: =gpg --clearsign filename=
  - verify signature: =gpg --verify filename=
  - configuration via =~/.gnupg=
    - =no-greeting=: don't show copyright notice
    - =defaut-key key1=
    - =keyserver hkp://subkeys.pgp.net=
  - =secring.gpg= The secret keyring
  - =pubring.gpg= public keyring
  - =trustdb.gpg= the trust database
  - GPG agent
    - =gpg-agent --daemon --enable-ssh-support --write-env-file ~/.gpg-agent-info=
- openSSL
  - =openssl enc -bf -a -in inputfile -out outputfile=
    - =-enc=: ecrypt
    - =-bf=: use BlowFish
    - =-a=: output =base64= encoded stream
    - decrypt with =openssl enc -d -bf -a -in inputfile -o outputfile=
  - network client: =openssl s_client -host www.example.com -port 443=
- Lab: generate gpg keypair. start gpg-agent. encrypt/decrypt file with gpg.
- Lab: encrypt and decrypt a file using openssl. Encrypt a tarball,
  then compress with xz. Repeat with compressing first, then
  encrypting
***** encfs
- implemented on top of =FUSE=
- =encfs ~/.encrypted_backend ~/decrypted=
- encrypts individual files, not block devices
- encfs backend can be shared by different users, each of whom will
  only see the files encrypted by their own password
***** LUKS
- implemented on top of device-mapper
  - see =dm-crypt= and =dm-mod= kernel modules
  - =cryptsetup= porcelain layer on top of =dmsetup=
- =cryptsetup --verify-passphrase luksFormat /dev/vg/lv_encrypted=
- =cryptsetup luksOpen /dev/vg/lv_encrypted crypt=
  - will create a =dm= block device =crypt=
  - =mkfs.ext4 -L crypt /dev/mapper/crypt=
- prompt decrypt on mount:
  - =crypt /dev/vg/lv_encrypted= in =/etc/crypttab=
  - =/dev/mapper/crypt   /path/to/mountpoint   ext4   defaults 1 2= in =/etc/fstab=
- Lab: create and format a LUKS filesystem. Set up multiple keys to access it
  - =cryptsetup luksClose /dev/mapper/crypt=
***** Extended Attributes and ACLs
=tune2fs -c 0 -i0 -o acl,user_xattr /dev/vg/lv=

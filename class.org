#+title: Enterprise Linux Security Administration
* Security Concepts
- Minimization
  - every installed component is a security risk, no such thing as
    innocuous service
    - every running component doubly so
      - services are no longer configured to start on boot by install
        scripts
  - discovery
    - packaged software
      - =rpm -qa=: all packages installed on system
      - =rpm -qi pkg=: info about package =pkg=
      - =rpm -ql pkg=: all files provided in package
      - =rpm -qf file=: which package provided the file
      - =rpm -qlp pkg.rpm=
      - lab (~5 mins)
        - objectives
          - use =rpm= do discover what packages are installed
          - trace dependency chain
        - tasks
          - list all packages installed
          - how many are there?
          - which package does =/usr/bin/openssl= belong to?
          - what packages require that package as dependencies?
          - now remove the packages in question
          - is this it?
            - =rpm -q --whatrequires $(rpm -q --provides openssl) | sort -u=
          - are we done now?
            - what do the packages we removed provide, and what
              depends on *that*?
    - unpackaged software
      - =find /where -user userid -exec rm {} \;=
      - =-ok= is like =-exec= but asks first
    - running processes
      - =chkconfig=
      - =netstat -taupe=
      - =ss -taupe=
      - =ps auxw=
      - =lsof -i=
      - lab (~5 minutes)
        - objectives
          - identify running processes
          - disable and uninstall unneeded software
        - tasks
          - which processes are configured to start at boot?
          - disable =avahi=, =bluetooth=, =xinetd= from starting on boot
          - what is listening on network?
            - =ss -taupe | grep LISTEN=
            - =lsof -i=
          - remove =xinetd= from the system
            - =rpm -e=
- Hardening
  - Already need a picture of who is going to access the service and
    what level of access they need
  - Do not trust default config!
  - Simplify!
  - packet filtering
    - pre-firewalld
      - config persists in =/etc/sysconfig/ip{,6}tables=
    - firewalld
  - service wrapping
    - =xinetd=
  - Authentication
    - PAM
      - shortcomings of PAM
  - minimizing service capabilities
    - least-privilege principle
    - =setuid=
    - POSIX 1003.1e capabilities
      - =capability.h=
      - =libcap=
        - =sucap=, =execcap=, =getpcaps=, =setpcaps=
      - lab 10 minutes
        - objectives
          - examine use of =capset()= and =setuid()= system calls
        - tasks
          - make sure =ntpd= is installed and running
          - what are the real and effective credentials of the =ntpd= process?
            - =ps -C ntpd -o comm,pid,ruser,euser,rgroup,egroup=
            - how does user =ntp= bind to port =tcp 123=, and how can
              it change system clock?
          - restart =ntpd= with tracing:
            - =strace -f ntpd -u ntp:ntp -g 2> ntp-calls &=
            - =grep -n bind ntp-calls | grep AF_INET=
            - =grep -n -B 5 capset ntp-calls=
              - which capabilities does it retain?
              - how does it change its effective user & group?
            - =grep -e [UG]id -e ^Cap /proc/$(pgrep ntpd)/status=
              - look for =Uid, Gid, Cap{Inh,Prm,Eff}=
    - =chroot=
      - lab 10 minutes
        - objectives
          - examine security implications of =chroot()=
        - tasks
          - install =busibox=
          - copy busibox and bash to =/tmp/jail=
          - =ldd *=, copy libraries to =/tmp/jail/lib=
          - =chroot /tmp/jail/bash=
          - =ls= does not exist!
          - use commands provided by =busybox=
          - from outside the jail, run =ls -la /proc/$(pgrep -xf /bash)/{cdw,root}=
      - SELinux is better!
        - no need to maintain multiple copies of software
* Scanning, Probing, and Mapping Vulnerabilities
- The Security Environment
  - Reconnaissance
    - public info
      - information never dies
      - profiling from public forums
      - WHOIS database
        - admin and technical contacts
        - netblock maintainer of the IP address
      - DNS
        - reverse lookup on target's IP address
          - why stop at one address? try nearby ones as well!
        - zone transfers
          - bulk transfer of all DNS entries in a zone
            - =host -l example.com=
    - discovery
      - =ping=
      - flood ping =fping=
      - =nmap=
        - ping sweep =nmap -sP 192.168.0.0/16=
          - if ICMP echo is filtered, try ICMP timestamp, or TCP
            connection to well-known ports
            - www.iana.org/assignments/port-numbers
            - /etc/services
        - IP stack and service fingerprinting
          - =nmap -sV -O target.example.org=
        - Lab (30 mins)
          - objectives
            - use =nmap= to discover and fingerprint services
          - tasks
            - install =wireshark=
            - ping scan of local network
              - =nmap -v -sP 192.168.0.0/24=
            - run ping scan again while running pcap:
              - =tshark -n=
              - what is the output?
            - run TCP connect() scan:
              - =nmap -sT target=
                - what flags are set in the scan packet?
                  - in the response for listening ports?
                  - closed ports?
              - decoy hosts
                - =nmap -sS -D decoy1,decoy2 target=
                - what will decoys see?
            - try =-f= option to fragment packets, see tshark output
            - try null and xmas scans
      - SNMP
        - UDP port 161 and 162 (snmptrapd)
        - =snmpnetstat -v2c -c public -Cr 192.168.32.2=
          - =-r= requests routing table
          - =-a= shows all socket info
        - =snmpwalk -c public -v2c 192.168.32.2=
      - RPC
        - portmapper listens on TCP port 111
        - applications select a free port to listen on, and register
          themselves with portmapper
          - =rpcinfo -p target.example.com=
          - =nmap= can still identify RPC applications even if it
            can't reach portmapper
      - enumerating NFS shares
        - =showmount -e target=
          - =-e= lists exports, =-a= shows active mounts
    - Insecurity Scanners
      - Nessus/ openVAS
        - NASL, Nessus Attack Vulnerability Language
          - update rules with =openvas-nvt-sync=
          - agent/server model
          - lab?: install openvas, tshark while it's running
  - Exploit Services
    - www.securityfocus.com
  - install backdoor
    - escalate privileges
    - rootkit
  - cover tracks
    - logsweeps
* Password Security and PAM
- local vs network passwords: =/etc/nsswitch=
- =/etc/passwd= -> =/etc/shadow=: =pwconv=
- trapdoor function: hashing
  - =crypt()=: DES encryption of password with itself as key (?)
    - weak!
  - =md5=, =bcrypt=, =sha256=, =sha512=
- password ageing
  - =/etc/shadow=: =chage=
- auditing passwords
  - John the ripper from openwall project
    - checkpointing: =session:FILE=, =-restore=
    - wordlists
    - Lab: use JTR to audit passwords
      - install JTR
      - =john -test=
      - create new user and set a password
      - unshadow the password file: =unshadow /etc/{passwd,shadow} > /tmp/passwords=
      - =john /tmp/passwords=
      - download wordlist and use it to seed JTR
        - =john -wordlist:morewords /tmp/passwords=
      - recompile a new master wordlist on the system
  - PAM
    - =/etc/pam.d=
    - is PAM support linked into the binary?
       =ldd /usr/sbin/sshd | grep libpam=
    - PAM Services (module types)
      - auth
        - authentication: verify identity, grant group memberships
      - account
        - authorization: is the user allowed to use this service at this moment?
      - password
        - used for password changes
      - session
        - executes code at start/end of a session. E.g. =ulimit=
    - a given module can provide more than one type:
      e.g. =pam_unix.so= can be invoked as any of the four types.
    - program checks its own PAM config file in =/etc/pam.d=, falls back to =other=
    - =include= statement to reduce code duplication
    - top-down processing, flow control statements in config
      - =required=
        - fails the stack, but processing continues
      - =requisite=
        - fails the stack, processing terminates
      - =sufficient=
        - passes the stack unless previous module failed it. processing terminates
      - =optional=
        - no decision on stack success
    - module menagery
      - ls =/lib/security=
      - =pam_unix=
        - refers to Name Service Switch to determine auth backend
        - can e.g. obtain kerberos ticket before session opened
        - password ageing, session logging
        - =use_first_pass= vs =try_first_pass=
      - =pam_pwcheck=
        - password strength enforcement
      - =pam_xauth=
        - transfers =X= cookies e.g. after =su=
        - =.Xauthority=
          - =~/.xauth/{import,export}= controls from/to which users
            this user can share cookies
      - =pam_tally2=
        - keep list of failed logins, can lock out
      - =pam_wheel=
        - policy on who can =su= to =root=
      - =pam_nologin=
        - if =/etc/nologin= exists, no non-root user can login
      - =pam_deny=
        - denies everything, secure default to terminate every stack
      - =pam_warn=
        - forces logging
      - =pam_securetty=
        - forces =root= to login through a 'secure' TTY, as listed in =/etc/securetty=
      - =pam_time=
        - enforces policy of which services will allow which users during which times through which ttys
      - =pam_access=
        - restricts access based on the location:
          =/etc/security/access.conf=: =permissions: users: origins=,
          where =origins= lists TTYs or hostnames
        - Lab: restrict user access from specified IPs
          - =/etc/pam.d/sshd=
            - =account required pam_access.so=
          - =/etc/security/access.conf=
            - =-:testuser1:ALL EXCEPT station1.example.com=
      - =pam_listfile=
        - arbitrary text files as a source of access control. Specify
          sense (allow/deny), item: user, tty, rhost, ruser, group,
          shell
        - Lab: restrict ssh access to a list of authorized users with
          =pam_listfile=
          - =/etc/pam.d/sshd=:
            - =auth required pam_listfile.so sense=allow item=user file=/etc/ssh_permit=
      - =pam_lastlog=
        - display time and location of last login. Taken from
          =/var/log/lastlog=
      - =pam_console=
        - set privileges on local tty differently from remote
          access. =/etc/security/console.perms=.
* Securing NTP
- =hwclock=
- =date=
- NTP terms
  - resolution
    - smallest interval measurable by clock
  - precision
  - jitter
  - accuracy
  - frequency error
  - reliability
  - wander
- synchronization services
  - Digital Time Sync Service (DTSS)
  - NTP: RFC 958(v0), 1059(v1), 1119(v2), 1305(v3)
- NTP v4
  - client-server & broadcast
    - multicast on 224.0.1.1, ff05::101
  - server hierarchy
    - stratum 0,1,2,..15
- =ntpdate=
  - slew vs jump update
- =ntpd=
  - multicastclient/broadcastclient
  - =broadcast 244.0.1.1= for multicast
  - driftfile
  - panic threshold
- =ntp.conf=
  - =restrict ntp1.example.com nomodify=
    - trust the time from =ntp1= but disallow it from modifying
      configuration
  - =restrict 172.16.1.0 mask 255.255.255.0 nomodify noquery=
- NTP integrity
  - symmetric encryption support in NTPv3 and v4
    - =/etc/ntp.conf=:
      - =keys   /etc/ntp/keys=
  - NTPv4 also supports 'autokey' (public key) encryption
    - =/etc/ntp.conf=:
      - =crypto /path/to/cert /path/to/rsa_key=
- =ntpq=
- =ntpc=
- =ntptrace=
- =ntpstat=
* Kerberos
** Concepts and Components
- 'crustacean' model of network security: fortify the perimeter and
  trust the internal network
- RFC 1510
- central trusted server, KDC, that authenticates and issues tickets
- authentication only, authorization is up to the service
- principals:
  - name, e.g. =user/admin@EXAMPLE.ORG=, has 3 components:
    - primary: =user=. For services, indicates service type,
      e.g. =host/= or =ldap/=
    - instance: mandatory for service principals. For users, usually
      used to modify capabilities given to the principal
    - realm: =EXAMPLE.ORG=
- session replay protection
  - each ticket carries a sequence number
  - sequence numbers do no roll over in the validity window, usually 5
    mins
- Kerberos Components
  - Authentication Server (AS)
  - Ticket-Granting Servier (TGS)
  - kerberized services using KDC
- GSSAPI
- SASL
** Authentication Process
#+BEGIN_SRC plantuml :file tmp/krb5_auth_process.png :cache yes
@startuml
"Client Workstation" --> "Authentication Server": obtain tgt
"Authentication Server" --> "Client Workstation": obtain sgt for service 1
"Client Workstation" --> "Kerberized Service 1": use sgt for service 1
"Client Workstation" --> "Authentication Server": obtain sgt for service 2
"Client Workstation" --> "Kerberized Service 2": use sgt for service 2
@enduml
#+END_SRC
** ticket attributes
- kerberos version + realm, unencrypted
- principal of the service, unencrypted
- principal of the user, unencrypted
- IP address of client host
- issued timestamp
- expiry timestamp
- session key to encrypt communication between client and service
** Authenticators
encrypted with tgt, opague for the client
contains
- Client's principal
- hash of the ticket
- timestamp issued
- sequence number to prevent replay attacks
** logging in
- obtain TGT. Optionally, AS can be set to require a pre-authenticator with the tgt request
- the pre-authenticator is salt + timestamp encrypted with the principal's password
- prevents brute-force attacks on krb AS service
** TGT request
- pre-authenticator
- message type = 10
- timestamps
- flags
- user principal
** TGT response
- message type = 11
- user principal
- encrypted with the user principal's key
  - timestamps
  - flags
  - client IP(s)
  - server TGS principal
  - session key
- encrypted with TGS key
  - TGS principal
  - timestamps
  - client IP(s)
  - user principal
  - session key
** SGT request
- request body
  - message type = 12
  - timestamps
  - flags
  - client IP(s)
  - supported enctypes
- TGT ticket, encrypted with TGS key
  - copied verbatim from TGT
- authenticator, encrypted with session key
  - user principal
  - hash of request body
  - timestamps
  - sequence number
** SGT response
- message type = 13
- user principal
- encrypted with user principal's key
  - timestamps
  - flags
  - client IPs
  - service principal
  - sub-session key
- SGT, encrypted with service's secret key
  - service principal
  - timesamps
  - flags
  - client IPs
  - user principal
  - sub-session key
** Service Access Request
- request body
  - message type = 14
  - mutual auth request
- service ticket: copied from SGT
- authenticator, encrypted with session sub-key
  - user principal
  - hash or request body
  - timestamps
  - sequence number
** Mutual Authentication Response
- message type = 15
- encrypted with session subkey
  - timestamps
  - sequence number
** Kerberos Components
- KDC
  - Authentication Service (AS)
  - Ticket-Granting Service (TGS)
- kerbrized services
  - telnet
  - ftp
  - rsh/rlogin/rcp
  - ssh
  - ksu
  - thunderbird
  - firefox
  - ssh
  - printing
  - imap/pop/smtp
  - web server
  - nfs
  - afs
** kerberos setup
*** KDC
- krb5kdc
- kpropd
- kadmind
*** utilities
- master KDC
  - kdb5_util
  - kprop
- admin clients
  - kadmin
  - ktutil
- principal
  - kinit
  - pam_krb5
  - klist
  - kdestroy
  - kpasswd
** kerberos daemon + utility relationships
kprop on kdc master -> kpropd on kdc slaves
kamdin on client -> kadmind on master kdc
kinit on client  -> krb5kdc on kdc (master or slave)
** administering and using kerberos
*** configuring master KDC

#+BEGIN_EXAMPLE /etc/kdc.conf
[kdcdefaults]
kdc_ports = 88
kdc_tcp_ports = 88

[realms]
EXAMPLE.COM = {
  acl_file     = /var/kerberos/krb5kdc/kadm5.acl
  dict_file    = /usr/share/dict/words
  admin_keytab = /var/kerberos/krb5kdc/kadm5.keytab
  supported_enctypes = aes256-cts:normal
}
#+END_EXAMPLE
*** KDC logging

Three types of data to be logged:
- default
- kdc: KDC logs
- admin_server

five possible destinations:
- FILE:filename: log to file
- STDERR: log to standard error
- CONSOLE: log to system console
- DEVICE=devicename: log to specified device
- SYSLOG:[severity:facility]: log to syslog

#+BEGIN_EXAMPLE /etc/krb5.conf
[logging]
kdc=CONSOLE
kdc=SYSLOG:NOTICE:DAEMON
admin_server=FILE:/var/log/kadmin.log
#+END_EXAMPLE

*** KDC realm defaults

- libdefaults: defaults for all krb libraries
- appdefaults: defaults for specific client apps
- realms: realms used by client
- domain_realm: map DNS domain names -> realm names
- logging: kerb client logging
- capaths: x-realm authentications

#+BEGIN_EXAMPLE
[libdefaults]
default_realm = EXAMPLE.COM
dns_lookup_realm = false
dns_lookup_kdc   = false
ticket_lifetime  = 24h
renew_lifetime   = 7d
forwardable      = yes
#+END_EXAMPLE

#+BEGIN_EXAMPLE
[realms]
EXAMPLE.COM = {
  kdc = server1.example.com
  kdc = server2.example.com
  admin_server = server1.example.com
}
#+END_EXAMPLE

*** DNS autoconfig
#+BEGIN_EXAMPLE
$ORIGIN example.com

_kerberos              TXT   "EXAMPLE.COM"
_kerberos._udp         SRV   0 0 88 server1.example.com
                       SRV   0 0 88 server2.example.com
_kerberos-master._udp  SRV   0 0 99 server1.example.com
_kerberos-adm._tcp     SRV   0 0 749 server1.example.com
_kpasswd._udp          SRV   0 0 464 server1.example.com
#+END_EXAMPLE
*** keytabs
- keytab for =kadmind= on RHEL is in =/var/kerberos/krb5kdc/kadm5/keytab=
- fetch keys and save in keytabs with MIT kerberos: =kadmin=
  - =getprinc=, =list_principals=, etc
- read and modify local keytabs: =ktutil=
*** ticket types
- initial: issued directly to principal. non-initial are granted on
  the basis of another ticket
- forwardable
- proxiable: used by services to authenticate on behalf of principals
- renewable
- postdatable: validity of tickets starts in the future. used e.g. by
  cronjobs
- invalid: used e.g. by postdated tickets before they are valid
*** managing principals
attributes
| allow_forwardable |
| allow_postdated   |
| allow_proxiable   |
| requires_preauth  |
| requires_hwauth   |
| allow_svr         |
| allow_tix         |
| needschange       |
*** principal policies
- maxlife
- minlife
- minlife
- minlength
- minclasses
- history
*** securing workstation login
use =*K*= in =/etc/shadow= to indicate the principal should
authenticate via kerberos. e.g. =useradd -p "*K*" user=

on RHEL6, the pam config bypasses obtaining kerberos ticket if unix
password is set:
#+BEGIN_EXAMPLE pam_config
auth sufficient pam_unix.so try_first_pass
auth sufficient pam_krb5.so use_first_pass

- =ksu= command:
  - =~/.k5login= lists principals allowed to log in as that user
  - "kerberized sudo": =~/.k5users= specifies which kerberos principal is allowed to execute specific commands
#+END_EXAMPLE
*** forwarding kerberos tickets
- non-forwardable TGT =kinit -F=
- =telnet -x= to have telnet try to use krb5. it's the default with
  newer versions onf telnet
- =telnet -xF= will forward local credentials to the remote system
*** securing ssh with kerberos
#+BEGIN_EXAMPLE
/etc/ssh/sshd_config

GSSAPIAuthentication yes
GSSAPICleanupCredentials yes

Host *
  GSSAPIAuthentication yes
#+END_EXAMPLE

- =kinit -f=
- ssh and transfer forwardable credentials: =ssh -o GSSAPIDelegatecredentials=yes targetserver=
- logout from ssh: =~.=
* Securing the Filesystem
** Mount Options
- =noexec= mount option on user-writable directories. At a minimum,
  =nosuid=, =nodev= for removable media.
  - attack vector: create a =suid= =root= binary on a removable media,
    mount and execute on target system.
    - Exercise: copy /bin/bash to usb stick and =chmod 6755=
  - variation (exercise): create a device file referencing the root
    FS, and escalate through that
** NFS
- similar attack vectors to removeable media: if a user has =root= on
  an NFS client, they can create =suid root= executables on the mount
  and try executing them on another machine to escalate.
- restrict allowable client list in =/etc/exports=
- root squashing is default: client =uid= 0 is automatically remapped
  to e.g. =nobody= on the server. Configurable with =anonuid/anongid=
  options. Can be disabled with =no_root_squash=. =all_squash= can be
  used to remap all access.
- =insecure= option allows access from clients bound to high port
  numbers. Does not really decrease security.
- Lab: examine mounted filesystems and correct mount options for
  better security:
  - e.g. /boot, /tmp, /usr, /var, /dev/shm
  - verify:
    - e.g. =mknod -m 777 /var/disk b 3 0= should fail
- Lab: create and exploit insecure =NFS= export
  - =/export/insecure 1.0.0.0/1(no_root_squash,rw,sync)= in =/etc/exports=
  - on a client, mount it and create a root-owned =suid= binary, eg. =vim= or =bash=
  - then execute the =suid= binary on the server or another client
- Lab: create a more secure export on the server and show it doesn't
  allow the =suid= or =mknod= exploit by the client. However, show the
  *client is still vulnerable to exploit by the server*. Correct mount
  options on the client to remedy.
*** NFSv4
- user names instead of =uid= numbers used by protocol to identify the
  users. No need to have =uids= match on both client and server.
- =rpc.statd=, =rpc.mountd=, =rpc.rquotad=, =rpc.lockd= no longer needed
- /pseudo-root/ exported via =/etc/exports=:
  =/srv/export  *(rw,fsid=0,no_subtree_check,async)=
  =fsid=0= (or =fsid=root=) declares the export to be the root of all exported
  filesystems
- =GSSAPI= to /mutually/ authenticate server and client to each other
  - =rpc.idmapd= daemon does the translation on both client and server
    - =/etc/idmapd.conf=
  - need =nfs/FQDN@REALM= keys for both client and server
  - integrity checking and encryption of NFS traffic
  - =rpc.svcgssd= on the server and =rpc.gssd= on the client
    - on RHEL, enable via =SECURE_NFS=yes= in =/etc/sysconfig/nfs=
    - need =prcsec_gss_krb5= kernel module to be loaded
  - require =GSSAPI= in =/etc/exports=
    - =/srv/export1  gss/krb5(rw,fsid=0,no_subtree_check,sync)=
    - =gss/krb5= for host and user auth
    - =gss/krb5i= to require integrity checking of NFS traffic
    - =gss/krb5p= to require encryption of all NFS traffic
  - to mount kerberos-protected exports, use
    =mount -t nfs4 -osec=krb5p server:/srv/export1 /mnt/=
- Lab: experiment with NFS and GSSAPI
  - create an NFSv4 export with 3 subdirectories, each owned by a
    different user, and =chmod= 700
    =/srv/export  10.0.0.0/8(fsid=0,rw,no_subtree_check,sync)=
  - observe that NFSv2/v3 mount of the export should fail
  - require GSSAPI auth for NFS and restart NFS daemons
  - require =gss/krb5i= on the export and re-export with =exportfs -r=
  - try mounting without GSSAPI or without requiring integrity
    protection: =mount -t nfs4 server:/ /mnt= or =mount -t nfs4 -osec=krb5 server:/ /mnt=
  - now try mounting with integrity protection:
    - =mount -t nfs4 -osec=krb5i server:/ /mnt=
  - try listing directory of a different user: =ls /mnt/userB=
  - now try creating =userB= on the client and =su= to it:
    - =su - userB=
    - =ls /mnt/userB=
    - should still fail since local =userB= does not possess the
      required kerberos ticket
  - now obtain the kerberos ticket as =userB= and access the directory:
    =kinit userB=
    =ls -la /mnt/userB=
*** GPG and openSSL
- GPG
  - generate keypair: =gpg --gen-key=
  - encrypt file: =gpg -e filename=
  - encrypt with symmetric password: =gpg -c filename=
  - decrypt (both symmetric and asymmetric): =gpg -d filename=
  - sign file: =gpg -s filename=
  - cleartext signature: =gpg --clearsign filename=
  - verify signature: =gpg --verify filename=
  - configuration via =~/.gnupg=
    - =no-greeting=: don't show copyright notice
    - =defaut-key key1=
    - =keyserver hkp://subkeys.pgp.net=
  - =secring.gpg= The secret keyring
  - =pubring.gpg= public keyring
  - =trustdb.gpg= the trust database
  - GPG agent
    - =gpg-agent --daemon --enable-ssh-support --write-env-file ~/.gpg-agent-info=
- openSSL
  - =openssl enc -bf -a -in inputfile -out outputfile=
    - =-enc=: ecrypt
    - =-bf=: use BlowFish
    - =-a=: output =base64= encoded stream
    - decrypt with =openssl enc -d -bf -a -in inputfile -o outputfile=
  - network client: =openssl s_client -host www.example.com -port 443=
- Lab: generate gpg keypair. start gpg-agent. encrypt/decrypt file with gpg.
- Lab: encrypt and decrypt a file using openssl. Encrypt a tarball,
  then compress with xz. Repeat with compressing first, then
  encrypting
*** encfs
- implemented on top of =FUSE=
- =encfs ~/.encrypted_backend ~/decrypted=
- encrypts individual files, not block devices
- encfs backend can be shared by different users, each of whom will
  only see the files encrypted by their own password
*** LUKS
- implemented on top of device-mapper
  - see =dm-crypt= and =dm-mod= kernel modules
  - =cryptsetup= porcelain layer on top of =dmsetup=
- =cryptsetup --verify-passphrase luksFormat /dev/vg/lv_encrypted=
- =cryptsetup luksOpen /dev/vg/lv_encrypted crypt=
  - will create a =dm= block device =crypt=
  - =mkfs.ext4 -L crypt /dev/mapper/crypt=
- prompt decrypt on mount:
  - =crypt /dev/vg/lv_encrypted= in =/etc/crypttab=
  - =/dev/mapper/crypt   /path/to/mountpoint   ext4   defaults 1 2= in =/etc/fstab=
- Lab: create and format a LUKS filesystem. Set up multiple keys to access it
  - =cryptsetup luksClose /dev/mapper/crypt=
*** Extended Attributes and ACLs
=tune2fs -c 0 -i0 -o acl,user_xattr /dev/vg/lv=
* SELinux
** DAS vs MAC
- DAC: discretionary access control, in the sense that a /subject/
  with certain access permission is able to pass that permission,
  perhaps indirectly, on to another subject
- most system resources are represented as files, wich are owned by a
  user and a group. Permissions are assigned to the files to determine
  the level of access for the owner, members of the owning group, and
  others.
- the owner can grant access at their discretion, and otherwise has
  full control over the file
- MAC: mandatory access control; a designated security administrator
  sets up access policies, based on which the system makes access
  decisions
- traditional UNIX security: historically, uid 0 (root) has 'god
  power' on the system. This means processes running as root typically
  have more privileges than they need
- POSIX capabilities carve out specific privileges that can be
  abrogated by a process to reduce the damage should it become
  compromised
- =suid/sgid=: a process is launched with the uid/gid of the /object/
  (the executable file) rather than the subject (user) who launches
  it. Classic example: =ping= needs to write IP packets, which is not
  available via unprivileged TCP/UDP API. Historically, =ping= was
  =suid= =root= until it was rewritten to use =POSIX= caps
- processes in the same security context have no limit on interaction:
  they can send signals to each other, e.g. SIGKILL. Segmenting by
  uid/gid is often too coarse. E.g. a CGI script launched by a web
  server will have security context of the web server and thus the
  same level of access to the system
** LSM
- Linux Security Module, created as a shim between NSA SElinux and the
  rest of the kernel to give reusable abstraction
** AppArmor
- an LSM (Linux sec module)
** SELinux
- goals: security administrator specifies policy, to be enforced by
  the kernel
  - policy allows the expected interactions within the system
  - original NSA security policy:
    - control raw access to data
    - protect integrity of the kernel
    - protect integrity of system software, system config, system logs
    - confine damage from exploit on a privileged process
    - protect privileged processes from executing malicious code
    - protect admin role and domain from being entered without
      authentication
    - prevent user processes from interfering with system processes or
      admin processes
    - protect users from exploits in the web browser by malicious code
- modes
  - enforcing and permissive
    - =setenforce 0/1=; =getenforce=, =sestatus=
- basic information about the state of selinux
  - =sestatus=, =sestatus -v= will give a list of contexts
    - =/etc/sestatus.conf=
- SELinux VFS
  - =/selinux/enforce=
  - =/selinux/avc=
  - =/selinux/booleans=
  - =/proc/pid/attr/*= - security context of the process
** Type Enforcement (TE) Security Model
- every object (file, process, ...) is assigned a type label. A type
  applied to a process is called a domain. Security policy defines the
  allowed interaction between domains and types.
- TE is the core enforcement model of the RH targeted policy
- RBAC security model
  - Users are assigned roles. A mechanism is needed to allow the user
    to transition between the allowed roles.
  - SELinux =newrole= command
  - Traditionally, system privileges are assigned directly to the
    various roles. With SElunux, each role is assigned a list of
    domains that may exist in it.
- Security Context (aka label) consist of 3 components:
  - identity: the owner of the object. =user_u= is the fallback
    default identity for UNIX accounts not explicitly mapped to an identity
  - role: for processes, the domain of the process. For files, a
    placeholder value =object_r=
  - type: classification of the object as to its specific security needs
  - security_level: of the form =sX-sY:cY-cY=
    - =sX= is the sensitivity level =s0-s15=
    - =cY= is the (optional) category =c0-c255=
  - =chcon=, =restorecon=, =/.autorelabel=
- Policies
  - RHEL SELinux policies
    - targeted policy: =unconfined_t=, =kernel_t=, =initrc_t=
      unrestricted domains
    - MLS policy: based on security levels and categories. LSPP, RBAC,
      and CAPP certification at EAL 4+. Mostly used in military or
      government deployments
    - Minimum policy: subset of the targeted policy
    - reference policy: original policy from NSA. Now by Tresys
      Technology
  - switching policies
    - =/etc/selinux/config=: =SELINUXTYPE=mls/minimum/targeted=
  - Policy Config Files
    - policy source, single binary policy (policy.XX), modular binary
      policy files (application.pp)
    - =/etc/selinux/=
      - =srtict=
        - =contexts=
        - =modules=
          - =active=
            - =modules=
              - =app1.pp=
              - =app2.pp=
          - =policy/policy.24=
      - =targeted=
        - =contexts=
        - ...
    - =apol= tool
- Booleans: toggle certain SELinux rules
  - =man -k _selinux= -> ... =httpd_selinux (8)=
  - visible in =/selinux/booleans=. Also =getsebool=. Also =semanage
    boolean -l=
  - changing in two stages: set and commit
    - via =echo 1 > /selinux/commit_pending_bools=
    - also =togglesebool= and =setsebool=. persistent with =-P=
  - =disable_trans= booleans
    - selectively disable transition to a confined
      domain. e.g. =httpd_disable_trans= keeps Apache running in
      =initrc_t= domain rather than transition to =httpd_t=. Caveat:
      files created by the service would be mislabelled. Not
      recommended.
- Permissive Domains
  - disable policy enforcement for a specific domain. The rest of the
    system is still protected by SELinux.
  - =semanage permissive -a <domain>=
  - =semodule -l | grep permissive=
  - restore confinement: =semanage permissive -d <domain>=
- Managing File Contexts
  - default context associates with every file
    - =semanage fcontext -l= lists the mappings of regexps matching on
      file path + file type to context
    - =semanage fcontext -a= to add a mapping:
      - =semanage fcontext -a -t httpd_sys_content_t '/myweb(/.*)?'=
- Managing port contexts
  - =semanage port -l=
- Lab: apply incorrect context to httpd document root
  - observe HTTP 403 error, and AVC error messages in the audit log
  - restore context
- Lab: toggle httpd_enable_cgi to off
  - install a simple cgi script, observe it run from command line
  - observe http 403 error and apache error log
  - =aureport --avc --failed -ts recent= to get report numbers
  - =ausearch -a report_number=
  - =sesearch --allow -s httpd_t -t httpd_sys_script_exec_t -p getattr -C=
  - toggle sebool back to on and observe CGI script run
** Examining Policy
  - =seinfo=
  - =sesearch= to display policy statements matching a search
    - =sesearch -A -s httpd_t= will list all AV rules involving =httpd_t=
    - =sesearch -A -s httpd_t -c file -p read -C= all files =httpd_t= can read
    - =sesearch -A -t shadow_t -c file -p write -C=
    - =sesearch -b allow_httpd_anon_write -A -C= what does =allow_httpd_anon_write= enable?
    - =sesearch -A -s httpd_t -c tcp_socket -p name_bind -C=  what ports can =httpd_t= bind to?
** SELinux Troubleshooting
- =auditd= is your friend: =/var/log/audit/audit.log=
- some denials are not logged due to =dontaudit= policy
  statements. Override with =semodule -DB= =semodule -b /usr/share/selinux/targeted/enableaudit.pp=
  - return to normal with =semodule -B= =semodule -b /usr/share/selinux/targeted/base.pp=
- =setroubleshootd=
- =sealert=
- fix file contexts with =chcon= or =restorecon=
- directories that need to be used by multiple services:
  =public_content_t=, =public_content_rw_t=
- allow service to bind to alternative port with =semanage port -a -t httpd_port_t -p tcp 8080=
** audit2allow
Lab: create x509 certificate for dovecot with wrong type,
e.g. =httpd_sys_content_t=.
- =tail /var/log/audit/audit.log=
- copy denial messages from audit.log and feed them to =audit2allow=
  =audit2allow -M dovecotextra < dovecot_failures.log=
- =semodule -i dovecotextra.pp=
- examine the type enforcement (.te) produced by =audit2allow=
  #+BEGIN_EXAMPLE
  module dovecotextra 1.0;
  require {
    type postfix_etc_t;
    type httpd_sys_content_t;
    class file read;
  }
  allow dovecot_t httpd_sys_content_t:file read;
  #+END_EXAMPLE
- =semodule -l | grep dovecotextra=
- cleanup: =semodule -r dovecotextra=
- proper fix: =chcon -t cert_t /path/to/x509/cert=
** Creating and Compiling policy from source
create policy module
#+BEGIN_EXAMPLE
policy_module(mypostfix_dovecot, 1.0)

gen_require('
  type postfix_t, dovecot_t;
')
type postfix_dovecot_cert_t;
files_type(postfix_dovecot_cert_t)

read_files_pattern(postfix_t, postfix_dovecot_cert_t, postfix_dovecot_cert_t)
read_files_pattern(dovecot_t, postfix_dovecot_cert_t, postfix_dovecot_cert_t)
#+END_EXAMPLE

create new file contexts file to make relabelling easier:

#+BEGIN_EXAMPLE
/etc/pki/tls/certs/*/email.*    gen_context(system_u:object:r:postfix_dovecot_cert_t,s0)
/etc/pki/dovecot/*/email.*    gen_context(system_u:object:r:postfix_dovecot_cert_t,s0)
#+END_EXAMPLE

=semodule -i mypostfix.pp=
=semodule -l | grep mypostfix=
=restorecon -v /etc/pki/dovecot/*/email.pem=
* audit
- what to audit
  - privileged operations
    - changing system time
    - tracing a process
    - using raw sockets
    - loading kernel modules
  - security events
    - SELinux AVC denials
    - PAM config changes
    - audit policy changes
  - login/logout
  - process creation
  - file access
- auditing login/logout
  - =/var/log/lastlog=
    - entry per user, showing last login time
  - =/var/run/utmp=
    - entry per terminal
  - =/var/log/wtmp=
    - history of who logged in and out
    - =last= command
  - =/var/log/btmp=
    - history of bad login attempts
    - =lastb=
- bash history
  - =chattr +x ~user/bash_history=
  - timestamp with HISTTIMEFORMAT
  - HISTFILESIZE, HISTSIZE
- psacct package
  - doesn't record process arguments
  - does not log until process finishes
- sudo logs
- kernel auditing
  - meets sec standards CAPP, LSPP, RBAC, NISPOM, FISMA, PCI, DCID 6/3
  - calls by a thread with auditable flag set are passed to the audit
    subsystem
  - =audit=1= option to kernel at boot time will make all processes
    inherit the auditable flag
  - audit records filtered before being passed to userspace
      #+BEGIN_SRC dot :cache yes :file tmp/a.png :cmdline -Kdot -Tpng -Gdpi=64
      digraph G {
          subgraph clusterKnlAudit {
            rankdir=LR
            "System Calls" -> "Exit"
            "System Calls" -> "Task"
            "Task" -> "System Calls"
            "Exit" -> "Exclude"
            "User" -> "Exclude"
            "Exclude" -> "Task"
            "kernel audit subsystem"
          }
          "Exit" -> "Application"
          "Application" -> "System Calls"
          "Application" -> "User"
          "kernel audit subsystem" -> "auditd"
          "auditd" -> "audisp"
          "auditd" -> "audit.log"
        }
      #+END_SRC

      #+RESULTS[2151b2b2167151eabc7a88828c17b53cd6e3ca95]:
      [[file:tmp/a.png]]

    - =exit=
      - checked at =exit(2)=
    - =task=
      - checked at =forc(2)= or =clone(2)=
    - =user=
    - =exclude=
      - suppress audit records
  - =auditd= picks up the filtered messages, appends them to audit
    log, and notiifies event dispatcher =audispd=
    - sample STIG-compliant config
      #+BEGIN_EXAMPLE
        log_file = /var/log/audit/audit.log
        log_format = RAW
        flush = SYNC
        disp_qos = lossless
        dispatcher = /sbin/audispd
        max_log_file = 1000
        max_log_file_action = KEEP_LOGS
        space_left = 75
        space_left_action = SYSLOG
        action_mail_acct = root
        admin_space_left = 50
        admin_space_left_action = EMAIL
        disk_full_action = SINGLE
        disk_error_action = HALT
      #+END_EXAMPLE
  - controlling the audit subsystem
    - =auditctl -s= to show current state
    - =auditctl -m message= injects a message
    - flags:
      - -e=0/1/2: disable/endable/lock audit config
      - -f=2: force kernel panic on critical error in audit system
      - -r num: rate limit, triggers critical error when exceeded
    - loading rules:
      - =auditctl -R /path/to/file.rules=
      - =auditctl -l -k user_defined_key= to list rules matching the key
  - creating audit rules
    - =auditctl -a list,action= prepend new system call rule to list
    - =-A list,action= append new system call rule to list
    - =-d list,action= delete the audit rule
    - =-D= delete all audit rules
    - =-w /path/to/file= add a file to watch
    - =-W /apth/to/file= no longer watch the file
  - syscall audit rules
    - =auditctl -a exit,always -S all -F pid=pid=
      - audit all system calls made py a process
    - =auditctl -a exit,always -S open -F auid=uid=
      - all files opened by user
    - =auditctl -a exit,always, -S unlink -S unlikat -S rename -S
      renameat -S link -S linkat -S symlink -F auid=uid uid=0=
      - attempts to delete, move, or symlink files by a user who
        changed to root
    - =auditctl -a exit,always -S mkdirat -S mkdir -S rmdir -F success=0=
      - failed attempts to create or delete directories
    - =auditctl -a exit,always -S EXECVE -F "uid>=500" -F "uid<=1000" -F "uid!=703"=
      - all processes started by uids between 500 and 1000, but not 703.
  - filesystem audit rules
    - =auditclt -w /etc/ -p wa=
    - =find /sbin -type f -perm +111 -exec auditctl -w {} -p a \;=
    - =auditctl -a exit,always -F dir=/etc -F perm=r -F "aiud>=500"=
      - reads of config files by non-system users
    - =auditctl -a exit,always -F dir=/var/www -F perm=w -F obj_type=httpd_sys_script_exec_t=
  - filtering record types with exlude
    - suppress SELinux AVC audit messages
      - =auditctl -a exclude,always -F msgtype=AVC=
  - searching audit logs
    - =ausearch -tm tty1 -m USER_START -m USER_END=
      - start and end of user sessions on =tty1=
    - =ausearch --start this-week --raw --uid-all 500 > /tmp/uid500_audit.log=
    - =ausearch --message PATH --interpret --success no --syscall open --loginuid 500=
  - audit reports
    - =aureport=
    - =aureport -l --failed=
  - combining =ausearch= and =aureport=
    - =aureport -k --summary=
    - =ausearch -k access | aureport -f --summary=
    - =ausearch -k access -f /path/to/file | aureport -u -i=
  - failed auth events
    =aureport --summary | grep logins=
    =aureport -l --failed -ts recent=
    =ausearch -a XXX=
    =ausearch -m USER_AUTH | grep user1=
    =auserarch -p pid -m USER_START,USER_END=
    =aureport --summary | grep logins=
  - auditing file access
    =auditctl -w /path/to/file -k=
    - add files to watch
      =auditctl -w /path/to/dir -k audit1_dir=
      =auditctl -l=
      - show all audit events associated with =/path/to/dir=:
        =ausearch -k audit1_dir -m PATH | grep ^time=
      - show audit records associated with appending data to file
        =ausearch -k audit1_dir -f append -i=
        results include
        - pointer to the string containing the file name (already
          decoded in the =PATH= audit record) in =a0=
        - flags to =open(2)= syscall in =a1=
          - lookup the flags: e.g. =a1=0x8441=:
            =echo "ibase=16; obase=8; 8441" | bc= -> 102101
            =egrep '\<0(100000|2000|100|1)\>' /usr/include/bits/fcntl.h=
        - effective uid in =a2=
  - all file events in the audit log: =aureport -f -i=
  - auditing command execution:
    - rule to log attempts to execute
      =/bin/rm= by =user1= =auditctl -a exit,always -F path=/bin/rm -F
      perm=x -F uid=1000 -k delete= can be easily evaded by user
      creating their own copy of /bin/rm, unless all user-writable file
      systems are mounted =noexec=. also, other commands can remove a
      file. Also, linker can be used to run the file, which will execute
      the linker, not the target executable: =/bin/ld-linux.so.2 /bin/rm /path/to/file=
    - rule to match all executions by =user1= match on syscall
      =auditctl -a exit,always -F uid=1000 -S execve=
    - `match unlink syscall to filter deletions
      =auditctl -a exit,always -F uid=1000 -S unlink,unlinkat=
* Securing postgres
** SSL
- generate SSL keypair, sign the certificate.
- place the certificate in =/var/lib/pgsql/data=
- set =ssl = on= in =postgresql.conf=
- force connections to use SSL in =pg_hba.conf=
- Lab: set up SSL for pgsql
  - generate key and req
    - =openssl genrsa -out pgsql.key 4096=
    - =openssl req -new -key pgsql.key -x509 -out server.crt=
  - enable ssl in =postgresql.conf=
  - restart pgsql
  - connect with =psql=
  - adjust SSL connection parameters: ciphers etc
  - disallow plain text connections in =pg_hba.conf=
** Access controls
- by default, no network connections allowed, so must be enabled with
  =listen_addresses = <list of ip addresses>= in =postgresql.conf=
- =pg_hba= by default restricts access to local users: user can
  connect only if they have an entry in =/etc/passwd= with the same
  name, and only connect to the database of the same name as the user
- =pg_ident= can override the default by mapping sql user name to UNIX
  users allowed to connect with that name
- =hba.conf= parameters
  - conn type:
    - local: UNIX socket
    - host:  tcp socket (default 5432)
    - hostssl: tcp socket with SSL enabled
  - auth_type
    - trust: bypass authentication
    - password: cleartext passwords (possibly in SSL tunnel)
      - passwords are stored in =pg_shadow= table
      - =CREATE USER bob WITH PASSWORD 'alice';=
      - if =WITH PASSWORD= is omitted, password is =NULL= and
        authentication will always fail for bob
    - md5:
    - ident:
      - locally: system username that connects on the UNIX socket
      - with host or hostssl: will trust reply from =identd= on the
        client machine. RFC1413. Not recommended.
    - krb5: GSSAPI
    - reject: what it says
    - ldap: passthrough to LDAP
- PAM for authentication
  - will passtrhough authentication to PAM. Highly configurable.
  - default service name =postgresql=, can be overridden
- GSSAPI
  - create service principal =postgres/host@REALM=
  - realm is ignored by postgres - careful of accepting principal from
    other realms in case of X-realm auth
  - configure =krb_server_keyfile= parameter in =postgresql.conf=
  - Lab: krb authentication
    - prepare keytab and require krb auth in =pg_hba.conf=:
      - =hostssl ALL ALL ALL ALL krb5=
    - reload postgres, and connect with =pgsql=
** Lab: pgsql as web app backing store
- =setsebool -P httpd_can_network_connect_db=1=
- set up the database, dedicated user, password, and entry in =pg_hba.conf=
* Securing mail with GSSAPI
- postfix
  - crate =smtp= principal and add to keytab
    - if postfix is running chrooted, make sure the keytab is the
      appropriate one, such as =/var/spool/postfix/etc/krb5.keytab=
    - also, if chrooted, create a tmp directory for krb session
      caches, and chmod 1777
    - if not chrooted, set =KRB5_KTNAME= to point to postfix' keytab,
      and import it in =main.cf=: =import_environment = KRB5_KTBANE=/etc/postfix/krb5.keytab=
    - also if chrooted, make sure SELinux allows =saslauthd= access to the socket:
      - =semanage fcontext -a -t saslauthd_var_run_t "/var/spool/postfix/var/run/saslauthd(/.*)?"=
      - =chcon -t var_run_t /var/spool/postfix/var/run=
      - =chcon -t saslauthd_var_run_t /var/spool/postfix/var/run/saslauthd=
  - configure =SASL= library to use GSSAPI:
    =mech_list: GSSAPI= in =/etc/sasl2/smtpd.conf=
- Cyrus IMAP
  - create principal =imap/FQDN@REALM=
  - add =sasl_keytab: /etc/imap/krb5.keytab= and =sasl_mech_list:
    GSSAPI= to =/etc/imapd.conf=
* Securing Apache
- =httpd.conf=
  =AddHandler= to allow executing CGI programs
  Allow CGI in directories with =ExecCGI= option, e.g.
  #+BEGIN_EXAMPLE
  <Directory /home/*/public_html>
    Options MultiViews Indexes IncludesNoExec ExecCGI
  </Directory>
  #+END_EXAMPLE
- File ownership & permissions
  - web content should *not* be owned by apache user/group (usually
    =nobody/nogroup=), nor should it be writable by them. Create a
    dedicated user & group, e.g. =webmaster=
- configuring CGI
  - always validate input to CGI scripts
    - perl: use taint mode =perl -t=. Untaints variables when regex is
      applied
  - =suexec=
    check restrictions with =suexec -V=
- Minimizing Attack Surface
  - deactivate unused modules, such as =cgi_module= or
    =userdir_module=
- delegating admin
  - =AllowOverride= directive within =<Directory/>=
    section. =AccessFileName= specifies which file is used for the
    override directives. Usually =.htaccess=
  - Limit scope of =AllowOverride=:
    - =AuthConfig=: auth directives; =AuthType=, =Require=, etc
    - =FileInfo=: document types such as =DefaultType=,
      =ErrorDocument=, etc
    - =Indexes=: index controls such as =DirectoryIndex=, =AddIcon= etc
    - =Limit=: =Allow=, =Deny=, =Order=
    - =Options=: specific directory features =Options= and =XBitTrack=
    - =All/None=
  - Examples
    #+BEGIN_EXAMPLE
    <Directory "/var/www/html">
      Options Indexes FollowSymLinks ExecCGI
      AllowOverride None
      Order allow,deny
      Allow from all
    </Directory>
    #+END_EXAMPLE

    Mask access to any file starting with ".ht"
    #+BEGIN_EXAMPLE
    <Files ~ "^\.ht">
      Order allow,deny
      Deny from all
      Satisfy All
    </Files>
    #+END_EXAMPLE

    #+BEGIN_EXAMPLE
    <Directory /home/*/public_html>
      AllowOverride FileInfo AuthConfig Limit
      Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec ExecCGI
      <Limit GET POST OPTIONS PROPFIND>
        Order allow,deny
        Allow from all
      </Limit>
      <LimitExcept GET POST OPTIONS PROPFIND>
        Order allow,deny
        Deny from all
      </LimitExcept>
    </Directory>
    #+END_EXAMPLE
- scrubbing HTTP headers
  - =ServerTokens=
    #+BEGIN_EXAMPLE
    ServerTokens Prod
    ServerSignature Off
    #+END_EXAMPLE
    =curl -Is http://localhost | grep Server
  - =expose_php= in =php.ini
- metering HTTP bandwidth
  - =mod_bandwidth=, =mod_bw.conf=
    #+BEGIN_EXAMPLE
    BandWidthModule On
    <Directory /srv/www/foo>
      BandWidth example 0
      BandWidth 10.100.0.0/24 0
      BandWidth all 1024
    </Directory>
    #+END_EXAMPLE
- HTTP User Authentication
  - http basic auth
    #+BEGIN_EXAMPLE
    AuthType Basic
    AuthName "Protected"
    AuthUserFile /home/user/.htpasswd
    Require user user1 user2
    #+END_EXAMPLE
  - standard auth modules
    - =mod_authn_dbm=
      Use =htdbm= utility to store usernames/passwords
      #+BEGIN_EXAMPLE
      AuthName "Protected"
      AuthType Basic
      AuthDBUserFile /home/user/webusers.db
      Require user1 user2
      #+END_EXAMPLE
    - Authenticating via SQL
      - generic SQL auth: =mod_authn_dbd=. Supports freeTDS, oracle,
        mysql, postgresql, sqlite, odbc
        #+BEGIN_EXAMPLE
        DBDriver pgsql
        DBDParams "dbname=www user=webauth password=secret"

        AuthName "Protected"
        AuthType basic
        AuthBasicProvider dbd
        AuthDBUserPWQuery "SELECT passsword from users where username = %s"

        Require valid-user
        #+END_EXAMPLE

        Where the database table is defines similar to
        #+BEGIN_EXAMPLE
        create table users ( username char(128) NOT NULL, password char(128);
        #+END_EXAMPLE

      - Also: =mod_authn_mysql=,  =mod_authn_pgsql=
    - Authentication via LDAP
      - =mod_authnz_ldap= module. Need RFC2307 schema.
        #+BEGIN_EXAMPLE
        <Directory /var/www/html/>
          AuthLDAPUrl ldap://ldap.example.com/ou=people,dc=example,dc=com???
          AuthType Basic
          AuthName "Restricted"
          Require valid-user
        </Directory>
        #+END_EXAMPLE
    - Authentication via Kerberos
      - =mod_auth_kerb= module
        - methods
          - password (passthrough)
          - negotiate method: uses tickets
        - =http/www.example.com= service principal
        - Needs SSL to prevent replay attacks
        - example config
          #+BEGIN_EXAMPLE
          SSLRequireSSL
          AuthType Kerberos
          AuthName "Restricted"
          KrbMethodNegotiate On
          KrbMethodK5Password Off
          KrbAuthRealms EXAMPLE.COM
          KrbKeyTab /etc/apache.keytab
          require valid-user
          #+END_EXAMPLE
      - enable krb authentication in Firefox
        - =about:config= or edit =prefs.js=
          - =network.negotiate-auth.trusted-uris= <- ='example.com'=
* HIDS
- rpm
=rpm -Va=
=rpm -V package_name=
- AIDE

* CISSP
+ Security Architecture
  - Bell-LaPadula Model
    - Basic Security Theorem
  - Clark-Wilson Model
  - Biba Model
  - RBAC
+ Kerberos/SESAME/GSSAPI
+ Architecture Evaluation Criteria
  - Orange Book
  - Red Book - TNI
  - Green Book - DoD Passwd Management
  - Dark Green Book
* C|EH v7
+ common SOA vilnerabilities
+ span port on switch
+ cross-site scripting
+ apache mod_negotiation - file extension
+ man nslookup
+ smurf attack
+ broadcast ping
+ google search hacks
+ ping of death
+ EAP - extensible authentication protocol - smartcards
+ metaspoit, nessus, nmap, tcpdump, wireshark
+ snort; ossec; tripwire
+ session hijack attack
+ syskey w2k8
+ XMAS scan
+ tcp seq # prediction
+ protect ag ARP poisoning - dhcp snoop table, dynm arp isp
+ WPA2 CCMP
+ OWASP, webgoat
+ PCI requirement 11
+ LM hash
+ swith CAM table
+ hping2
+ OSSTMM
